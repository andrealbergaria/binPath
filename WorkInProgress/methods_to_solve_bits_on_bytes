PRIMEIRA TENTATIVA )
) 
	Tendo numero ,por exemplo 1011,quais os valores que
	Pos4 =1 ,Pos3= 0 , Pos2=1 ,Pos1 =1
	
	usar a matrix
   [0 0 0 1]	 If [1 0 0 0 ] AND [1 0 1 1]
   [0 0 1 0]	 If [0 0 1 0 ] AND [1 0 1 1]
   [0 1 0 0]
   [1 0 0 0] 		
   
   Pode ser
   	[0 0 0 1] [1 0 1 1]
   	[0 0 1 0] [1 0 1 1]
   	[0 1 0 0] [1 0 1 1]
   	[1 0 0 0] [1 0 1 1]
   	
  SEGUNDA TENTATIVA)
  to scan all bits, for better speed, fix at least one bit
for example

for 256 bits, set the first bit (one or zero) making it to scan 128 (less the first bit , which we fixed, and can be 0 or 1)
  
  TERCEIRA TENTATIVA)
  Algorithm to test all combinations 
  Start at using 1 bit set, and other bit always shifting right 
  the at end position start  shith left 
  	left to right (each bit shifted right one time)
  	Same value (doesnt work) zeros at left
    => 10 => 010 => 0010 => 00010
    
    right to left
    1000 <= 100 <= 10 <= 1  
    
  QUARTA TENTATIVA
  
  when a bit changes (a new number) , cahnges the position or substituing,
{1, 1, 0,0 } = 12
(0,1,0,0 } = 4d
{0,0,1,0 } = 2d

(3,2) 4d -> 2d

{1, 1, 0 ,0}
{1, 0, 0 0 }

se substitui, 0 para 1  então usa-se o bitshift left com 1 posicao
se substitui  1 para 0  entao numero = numero - 2^pos

position has to be between pos-1 , or pos1+1

position to the left
bitshift by one
position to the riht
bitshift by one

  QUINTA TENTATIVA
  
  	(0,0,0)
  	(1,1,1) -> reverse
  	(1,0,0)(0,1,0)(0,0,1), para obter a proxima combinação reverse os numeros
       3       5     6
    (0,1,1)(1,0,1)(1,1,0)
        			
      12			10		 9
    (1,1,0,0) (1,0,1,0) (1,0,0,1) add 1 to 3bits
      11			13			14
    (1,0,1,1) (1,1,0,1) (1,1,1,0)
        			
    SEXTA TENTATIVA
    
    add eight to several cells at the smae time, or use a mask ,that way it saves cyclse 
    for example
    
    pos1  pos2  pos3
    +8   +8    +8  
          			
    SETIMA TENTATIVA
    
                   Permutation of 1 byte 2byte the same value      		
   							Pos 1			Pos2  		Pos3=Pos2
   				x	1 2 3 4 5 6 7 8   1 2 3 4 5 6 7 8
   
   				y	2 1 3 4 5 6 7 8   1 2 3 4 5 6 7 8
   
   				z	2 1 4 3 5 6 7 8   1 2 3 4 5 6 7 8
   
   
   					copiar permutation(x,y) -> pos2(x,y)
   					copiar pos2(x,y) -> pos3 (x,y)
   					
   	OITAVA TENTATIVA
   	
   	
 0000   0 
 0001   1 
 0010   2 
 0100   4 
 1000   8
 0111  7 	From 0 to 8, 4bits equals = 3bits
 0110  6 
 0101  5 
 0011  3
 
 REAL VALUES (Start with 1)
 1111  15 	 
 1110  14
 1101  13
 1011  11
 0111  7		from 9  to 16 bits 4bits
 1000  8
 1001 9
 1010 10
 1100 12
 
5 bits)  from 16 to 24 bits 5bits

10000 16
10001 17
10010 18
10011 19
10100 20
10101 21
10110 22
10111 23	
11000 24
11001 25
11010 26
11100 27
11101 28
11110 29
11111 30
 
 get all numbers that begin with 0, then invert them to get the real numbers.Then ignore them (they all begin with zero, so they are equal
 to the 3BITS before
 				
   
    1 1 1 1
	1 0 1 1 (Change one bit from 1111) 
    0 1 1 1 (Change one bit)
    1 1 0 1
    1 1 1 0
    
    invert all values (Base 1111)
    
    0 0 0 0 
    0 1 1 1
    1 0 0 0 
    0 0 1 0
    0 0 0 1
    
   				
NONAGESIMA TENTATIVA

Separate bits into letters
             
                0101 | 0100 | 1010 | 1010 | 1011 
                 AA     AZ     BB     BB     BC    
                 
                       		
DECIMA TENTATIVA

         algorithm       algorithm
      a)  [0] Bit bit Bit [0] bit bit bits
             
      b)  [0] bit bit bit [1] bit bit bits
             
      c)  [1] bit bit bit [0] bit bit bit
             
      d)  [1] bit bit bit [1] bit bit bit
              

TENTATIVA NUªMERO 11
    		First Byte		
                  	0
                  	
                  	1
                  		SeconByte = FirstByte Copy FirstByte or FirstByte, and then reverse it (01 -> 01)
                  	
            		0
            		
            		1		can revert binary numbers ( 0->1 , 1->0 , 0-> 1 , or just set the bits with leading ones those belong to second byte)
            				If leading zeros, then second byte = first byte
            		0
            		
            		1
            		
      					Third Byte = SecondByte copy SecondByte OR ThirdByte = Seocndbyte, instead of copyiong reverse it
      					
      				0
      				
      				1
      							Already assigned first two combinations of zeros and ones (4 combinations  2 zeros and ones)
      				0      				
      				
      				1
      				
      				0 
      				 			Set equal to the last numbers (starting from line 4) or reverse numbers
      				1 
      				
      				0 
      				
      				1	
      			
      				Assign first bit to 1 (2bytes-> pos(1),pos(4)  , 3bytes-> pos(1),pos4,pos 6 ,pos 8) need to copy byte to byte and then 
      				set 1 on leading positions  in even positions 
        
                	reversing numbers faster than setting it?
      			
                            
           

   TEATNIVA NUMERO 11
   multiplicat 6bits = 5bits * 2 muit olento
                Xbits is a subset of X+1bits
   
   
   TENTATIVA NUMERO 12
   char arr[8] = 3bits
            
            char 4bits[1] = 3bits;
             	 4bits[0] = 1;

			char 5bits[1] = 4bits;
				 5bits[0] = 1;            	
			
			char 6bits[1] = 5bits
				 6bits[0] = 1       ......       	
   
   PAra 9 bits
   		char 9bits = 		    