       /*
     * 
     * 
     * Positions          1             2               3           4           5       6           7           8
     * Values             0             1               2           3           4       5           6           7
       bitStrings 1)   00000000      00000001       00000010    000000100    00000101 00000110  00000111     00001000 (64bits)
       
        2) Values         8+1           8+2             8+3          8+4         8+5     8+6    8+7         8+8
     *                 00001001      00001010       00001011   00001100     00001101 00001101  0000111      00010000

       3) Values        8+8+1          8+8+2       8+8+3       8+8+4          8+8+5    8+8+6   8+8+7       8+8+8
                       00010001      00010010       00010011   00010100     00010101  00010110 00010111     00011000
     
      
       
      
      
      29)           8*28 + 1 225   
                       11100001
                       
    30)             8*29+1 233
    
    32)             8*31 + 1 249
        
         required : 8ints 32 bytes
            
                    8*32 (256)
                    
               
               trying 256 * 256
               {0,1,2,3,4,5,6,7,8}              * 256    {0,1,2,3,4,5,6,7,8}
               
               0000 0000 , 0000 0001, 0000 00002
               0001 0000 , 0001 0001, 0001 00002
               0002 0000 , 0002 0001, 0002 00002
               
               
               
               
               
                                 8*3 = 24 comb so far (only with 1) 2) and 3))
                                 
                                 2^8 = 256 needed combs
                                 
                                 
                                 Pos 1 = ,0,1,9,17,25,33,41,49,57,65,73,81,89,97,105
                                 
                                 Pos 2 = ,0,2,10,18,26,34,42,50,58,66,74,82,90,98,106 (all evens)
                                 
                                 Pos 3 = ,0,3,11,19,27,35,43,51,59,67,75,83,91,99,107,115,123,
                                 
                                 Pos 4 = ,0,4,12,20,28,36,44,52,60,68,76,84,92,100,108,116
                                   
                                 Pos 5 = ,0,5,13,21,29,37,45,53,61,69,77,85,93,101,109,117
                                 
                                 Pos 6 = ,0,6,14,22,30,38,46,54,62,70,78,86,94,102,110,118
                                
                                 Pos 7 = ,0,7,15,23,31,39,47,55,63,71,79,87,95,103,111,119,
                                 
                                 Pos 8 = ,0,8,16,24,32,40,48,56,64,72,80,88,96,104,112,120,128,136
                                 
                                 
                                 o algoritmo e igual para cada posiçao , mas tem de se começar com um valor a mais no ciclo
                                 
                                 
                                 visto que alguns valores sao repetidos tomar partido disso
    aes 128, 192 e 256 bits (chave)
   256 -> 32 bytes
   32/4 = 8 ints
      unsigned long // 8 bytes  +  18,446,744,073,709,551,615] 
     unsigned int 4294967296
     
     
     
     pos1  pos2
     1		4
     
     2		5
     
     3		6
    ------------ 
	3		4
			
	2		5				PERMUTATION POS1
			
	1		6
-------------   
   
   3		5
   
   2        4			PERMUTATION POS2
   
   1 		6
   
   
   
     
     				cycle once to set all positions
     				permute some positions
     				
   						 1			3
   	procedure -> copy pos1 to all positions
   			 ->  permute position1 and save all of permutations in aray
   			 -> Pos2 = array
   			 -> pos2 = pos1											From position1
   			 -> pos3 = array (array that contains all permutations 1...8)
   			 -> pos3 = pos1
   			 
   			 ....
   			 -> Permute position2 and put it on array
   			 -> Pos 3 = array
   			 -> 
   			 
   			 Permutate 3 pos
   		(1,1,1)
   		(1,1,2)					(1,1,2) = (1,2,1) => line2 are permutations
   		(1,1,3)					
   		
   		Para cada permutacao , igualar pos3 index => 
   		
   			Permutate 2 pos
   		(1,1,1)
   		(1,2,1)
   		(1,3,1)
   		
   		
   		PErmutate 1 pos
   		(1,1,1)								Pos1			Pos2 		Pos3
   		(2,1,1)						line2 => (2,1,1) 	  (1,2,1)		(1,1,2)	
   		(3,1,1)
   											Pos1		Pos2		Pos3 
   									line3 => (3,1,1)	  (1,3,1)		(3,1,1)
   		
   		copy array a = {1,2,3,4} 1) posicao 1 ,depois posicao 2 etc...
   		
   		
		changes both 1 . 2 and 3 positions
		
		POsitions 1 => (2,1,1)
		Positions 2 => (1,2,1)
		Position 3 => (1,1,2)
		
				
		(1,1,1)
		(2,1,1) change on pos1
		(3,1,1)
		
		(1,1,1) 
		(1,2,1) change on pos2
		(1,3,1)
		
		
		(1,1,1) Change on pos3
		(1,1,2)
		(1,1,3)
		
		(2,2,2) 
		(2,1,2)
		(2,3,2) position2
		
		
		(2,2,2) chagne on position3
		(2,2,1)
		(2,2,3)
		
		(3,3,3)
		(1,3,3)
		(2,3,3)
		
		(3,2,3)
		(3,1,3) change on pos2
		(3,3,3)
		
		(3,3,1) change on Pos3
		(3,3,2)
		(3,3,3)		
		
		 
		
		 uma permutacao em pos1 , permuta o mesmo em pos2
	
	
		 
   pos1(2,1,1) -> pso2(1,2,1) -> pos3 (1,1,2)
   pos1(2,2,1) -> pos2(2,1,2) -> pos3(1,2,2)
   pos1(2,2,2) -> pos2(2,1,2) -> pos3(2,2,1)
   
   
    
   pos1(3,1,1) -> pos2(1,3,1) -> pos3 (1,1,3) 
   
   
   Array[8!] = { (1,1,1,1),(1,1,2,1) ,(1,2,1,1),(2,1,1,1) ....}
   
   