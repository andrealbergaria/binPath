 /*
 


a) 0110
b) 0011
c) 0100

how many zeros are there ? a) 2 b) 2  c)3 



4 bits

4 BIT DIVISION (only zero first numbers)
0000  (0d)
0001 (1d)
0110 (6d) 						order of leading zeros and their number
0010 (2)  -> AGRUPAMENTO Q   => (0,0,0,0)   
0011 (3)					    (0,0,0) 		1d
								(0,0) 			2d
								(0,0) 			3d
								(0) 			4d
								(0) 			5d
0100 (4)						(0) 			6d
0101 (5)						 
0111 (7) 						
								

								(0) 			7d
																	4 BIT DIVISION	
											(0,0,0,0,0,0) 0d  			(0,0,0,0) 0d
5 BIT DIVISION (only zeros)					(0,0,0,0,0) 1d				(0,0,0)   1d
000001										(0,0,0,0)  3d	   			(0,0)  2d
											(0,0,0) 4d					(0,0)  3d	
000010										(0,0,0)  5d					(0)    6d
000011										(0,0,0 ) 6d					(0) 4d
000100										(0,0,0,) 7d					(0) 5d
000101										(0,0,) 8d					(0) 6d
000110 
000111
001000	8d				
001001 9d
001010 10d
001011	11d					
001100 12d
001101	13d					8,9,10,11,12,13,14 = 2 , 3
001110	14d					7,6, 5, 4 = 1d
							
							
							7 = num of bits pode ser com 3 bits    
							8d thruogh 14d = tem de ser com 4 bits 
							
001111
									f(
									
									num_of_bits (like 4 BITS or 5 bits ..not add bits) , which number
									f(X) = 

							 
Para valores menores que (8,16 (0b1111),31 0b11111,63) 
	
	
	0 <=  agrupamento_Q < 8
	8 <=   agrupamento_w < 16  (comeca por 1 ignorar)
	16 <=  agrupamento_j < 24 
	24 <= agrupma.....< 32  (comeca por 1 ignorar)
	32 <= ar.....   < 40
	40<= .... < 48 comeca por 1 ignorar
	48 <= .... < 56
	56<= .... < 64 1 ignorar 
	64<=   ... < 72
	
	
	0,16,32,48,64
						num de bits estao relacionado ?
	quanto zeros 0 ? => 4+3+2+3+2+3+2+1 = 20 zeros 
	quantos zeros 16?
	


								
1000 8
1001 9
1010 10		-> AAGRUPAMENTO W
1011 11					  	
1100 (12
1010 13
1001 14
1111 15

obter numero de zeros a esquerda (4bits) , metade dos valores tem 0 no inicio
		if (firstBit == 0 )
		

 
		(b1,b2)
		(b1,b1)
		(b2,b2)
		(b2,b1)		
		numero total de mudanças de ordem
		4
		
		
		
		Se 3 belongs to i, and 2 belongs to i then both belong to i
		
		or 3 = 2 = i
		
		obter todas as combinações , do conjunto em que tenha 3 bits
		quais os limites?
		1 <= 3 <= 8 ?

		
		  				
	
1	1	1	1   1
AGRUPAMENTO A

	0	1   1	1 
	1	0	1	1  => one zero per linhe      Numeros binarios em decimal neste agrupamento (7,11,13,14)
	1	1	0	1
	1	1	1	0
	
AGRUPAMENTO B   TRANPOSTA DE A?
 
	0	0	1	1
	0	1	0	1
	1	0	0	1  
	1	1	0	0 => dois zeros per line  (3,5,9,12,6,10)
	0	1   1   0    
	1	0	1	0
	
AGRUPAMENTO C
	0	0	0   1 		
	0	0	1	0 => tres zeros per line (1,2,4,8)
	0	1	0	0
	1	0	0	0
		 
	0	0	0	0
-----------------------		
	Ao adicionar um , apenas de adiciona um. Se se adicionar um zero, se o anterior ou o posterior for zero, nada se aumenta nada
	
	Para cada agrupamento , o NUMERO de uns e zeros é igual em cada linha. 	
	
	Agrupar 4bits, por numero de zeros (ou por uns). assim contar as combinações de uns (java igual zeros as variaveis por default)  
	
	4 * 1zero (7,11,13,14)			Number of zeros no agrupamento A = 4 zeros
	6 * 2zeros (3,5,9,12,6,10)		numero de zeros no agrupamento B = 12 zeros
	4 * 3zeros (1,2,4,8)			Numero de zeros no agrupamento C = 12 zeros
	
	4 bits começando por zero (0111, 0101,0110,0011,0001,0010,0100,0000) são iguais a 3 bits, então para obtermos todos os 4 bits,
	basta adicionar 1 no inicio		
				



relationsship between 4 bits and 3 bits
	
	 
				relationship betwen first bit and second bit 
			trying only with ones (use cycle to iterate index and assign ones
			zeros are already taken by java
			
			first bit
			2,4,6,8		10,12,15,16
			
		
			
				// Set first bit to 1
				// set second bit to 1
				// set third bit to 1
			
				
			3,4,7,8,	11,12,15,16
		
			third bit
			5,6,7,8,	13,14,15,16		
	  	 
			 
			 
			  
			  
			*/
		
	//	int[] another = new int[16];
		
		
		// skip counting zeros, just assign arrays to 1..the others are 0
	/*	
		
		n) = m) + 1111 + m)		
			
			 0000 0111 + 0000 1111  + 0000 0111
		
	set 2    set 1	
	m)	0000 0111	7		
		0000 0011	3
		0000 0101   5
		0000 0001	1		 (1,2,3,4,5,6,7,8)
		0000 0110	6		+1111 +1111 +1111  	
		0000 0010	2			
		0000 0100	4
		0000 1000  8
		
		 
		112   7				119-112 = 7d 
	n)	0111 0111 119 		we subtract the number 
							from the 1set of binaries to
							the number (119d-0111b (7d) on 7 on m)
							and another example 51d-011 on 3 on  m) 
		0011 0011 51
		0101 0101 85
		0001 0001 17
		0110 0110 102
		0010 0010 34 
		0100 0100 68 
		0000 1000 8						
		
o)		0111 0000 112					set 1 = tem de ser igual a (1,2,3,4,5,6,7,8)  ou tudo a zeros?
										set 2=   (1,2,3,45,5,6,7,8) ou zeros ?
		0011 0000 48
		
		0101 0000 80
		0001 0000 16					1 = (1,2,3,4,5,6,7) 	?						0  = zeros??
		0110 0000 96					
		0010 0000 32					(1,1) (0,1) (1,0) (0 , 0) => Todas as ordens possiveis
		0100 0000 64				
		1000 0000 128						
		
		
												0,17,34,51,68,85,102,119
		o) = m) + 1111
		n) = o) + m)
								minus -     0  1  2  3  4  5  6  7  m)  ( 0, 1)
	
	
    
    
											    0,16,32,48,64,80,96,112 o) (1,0)
		
								divide_by_16 
								
												0,1,2,3,4,5,6,7					
			
				shift esquerdo = dividir por 16
				k= h)#1 / g)#1 = 16  
				k= h)#2 / g)#2 =  16
				k= h)#3 / g)#3  =  16
				
					f(g) = h)#1 / k , com k= 16
							
					i#1-g#1 = h#1
				
					f(g) = (i#1-g#1) / k
								

				
				a constante é 16 neste caso (para outros bits serao o mesmo)
				
				
				
								
g)  0000 1000	8d							
	0000 1001   9d
	0000 1010   10d
	0000 1011   11d
	0000 1100	12d
	0000 1101   13d
	0000 1110   14
	0000 1111   15
	0000 1111  16
	
	
	
h)							128 = 8*16   ( 8d * )
	1000 0000  8k = 128 , k=  128 / 8 => 16d = 8d
	1001 0000  144 = 9K = k= 144/9 => 16					
	1010 0000	160 = 10k = 16	 										
	1011 0000
	1100 0000
	1101 0000
	1110 0000
	1111 0000
	
	 
	
i)
	1000 1000  		i#1 = g#1+h#1 
	1001 1001  		i#2 = g#2+h#2   
	1010 1010  		 	
	1011 1011
	1100 1100
	1101 1101
	1110 1110
	1111 1111
	
												
					
		linha=8 bytes
		col = 2
												
												
					(1,1,1)(1,1,0)(1,0,1)(0,1,1)(0,0,1)(0,1,0)(0,1,0)(000)		
													
						0 = zeros?	1= (1,2,3,4,5,6,7) or 1 = (1,2,3)			
												

		bits iniciais 4 , maximum => 2 positions
		bits iniciais 8 , maximum => (2^3) 3 posicoes 		
		bits iniciais 16 , maximum => (2^4) 4 positions
		bit  iniciais 32 , maximum -> 5 positions 
		bits iniciais 256 , maximum => 8 positions 
		bits iniciais 512 -> maximum => 9 positions 
		bytes iniciais 4294967296 -> 32 positions?
				
				ou seja vai diminuindo pela posicioes.....(menos 2vezes)
		
   4    3   2   1 				
b)	1	1	1	1 
	0	1   1	1 
	1	0	1	1  
	0	0	1	1  
	1	1	0	1    
	0	1	0	1		4 coluna = 3 coluna de a)   
7	1	0	0	1		3 coluna = 2 coluna de a)
	0	0	0   1 		2 coluna = 1 coluna de a)
	1	1	1	0		 
	0	1   1   0    
	1	0	1	0
	0	0	1	0
	1	1	0	0		
	0	1	0	0
15	1	0	0	0		 
	0	0	0	0
		
	
	(4,3,2) ->  2threebits
	(1,2,3) -> nada
	 
	8 bits-> 32
	9 bits-> 64
	10 bits ->128
	11 bits -> 256
	12 bits -> 512
	13 bits -> 1024
	14 bits -> 2048
    15 bits -> 4096										
	16 bits -> (anterior ) * 2  
			-> 8192 * (1.....8192 of three bits)
					
					7 * 8192
					57344
					
		3bits ->8 combinações
		
		threeBits(7) = #8
		threeBits(15) = #8
	
	
	poupar 3 bits pois ao sempre igaugis em todas as posicoes
	
		threeBits = 16 elemets
	3 bits -> 1 * threeBits(7); => 8
	
	4 bits -> threeBits (7,15)  => 2*8 // 2*8
	
	5 bits -> threeBits (7,15,23,31) // 4*8
	
	6 bits -> threeBits (7,15,23,31,39,47,55,63) //8 * 8 

	
	//-- three marker bits
	
	5 bits- > (4bits,23,31)
	6 bits-> (5bits,39,47,55,63)
	7 bits-> (6bits,71,79,87,95,103,111,119,127)
	
	256 bits have 3 bits initials 
	
	/*Percorrer o mesmo ciclo e adicioainar 7
	
	15    = 0b1111
	23    = 0b10111 (15+7)
	31    = 0b11111 (23+7)
	
	byte1
	0b0 0 0		
	0b0 0 1			
	0b0 1 0		
	0b0 1 1		
	0b1 0 0		
	0b1 0 1		
	0b1 1 0		
	0b1 1 1		
				
					
	byte2
	0b0 0 0
	0b0 0 1
	0b0 1 0
	0b0 1 1
	0b1 0 0
	0b1 0 1
	0b1 1 0
	0b1 1 1 	 
	
	since they are equal to the first byte, one can assign without cycle
	
	3bits , All combinations = 2^3 = 8 bits
	4bits , All combinations = 2^4 = 16bits
	5bits , All combinations = 2^5 = 4 bytes
	6bits , All combinations = 2^6 = 8 bytes
	7bits , All combinations = 2^7 = 128combs
	8bits , All combinations = 2^8 =  256 combs
	256bits , All combinations = 2^256
	
	1)00 10 01 11 2^8 = 256 combs 2) 11 01 10 01 = 256comb 2^8
	 
		se 2^8 entao todas as combinações no primeiro byte
		de 1) são iguais ao 2)
			
			
			 o prmeiro byte vai ser semptre [1...256]
			 o segundo byte vai ser sempre [1..256]
	 para 2 bytes
	 primeiroByte[1...256]	primeirobyte[1...256]
	 segundo byte[1...256] primeirobytye[1...256]
	 segundobyte[1...256] segundobyte[1...256]
	primeriobytye[1..256] segundo[1...256]
	
	n=2 , p =2
	
	{p,s} => {ps,sp,ss,pp}
	 
	n={1,2,3,4}
	p= {4}
	
	it a = 2^8
	arr[a][a] = [1..256][1..256][1..256]
	aplus = 2^8*2
	
	arr[1plus[
	1 -> index da array
	Para 1 byte
	[1....256]
	Para 2 bytes 
	2->index da array = position 2
	[1...256] [1...256] // concat
	1) = anterior
	2) = anterior
	3) = anterior
	
	
	
		
		
	
	//int endByte=4;
	//int endByte=0;
	//for (int startByte=0; startByte < 32; startByte+=4) {
	//		it+=printSixTeen(res,startByte,endByte);
	//		endByte+=4;
	//	}
	//}
	int[][] res = new int[32][32];
	int sizeByte[] = {  0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 254 , 255 }; 
	for (int pos = 0 ; pos < 32; pos++) {
		for (int pos2 = 0; pos2 < 32; pos2++) {
			res[pos][pos] = sizeByte; 
		}
	}
	
	/*printSixTEen(res,0,4);
	printSixTeen(res,4,8);
	printSixTeen(res,8,12);
	printSixTeen(res,12,16);
	printSixTeen(res,16,20);
	printSixTeen(res,20,24);
	printSixTeen(res,24,28);
	printSixTeen(res,24,28);
	*/
	
	
	

     
	
	
		//printArray(arr);
		//printMultipleArray(res);
	
	
	// Return iterations
	private static int printSixTeen(int[][] res,int startingByte,int endByte) {
		
		int it=1;
		
		System.out.println();
	 for (int i =startingByte; i < endByte; i++) {
		 	 for (int i3 = 0 ; i3 < 256; i3++) {
	 	 		res[i][i] = i3;
	 	 		it++;
			 }
		 }
	 
	 
	 
	 System.out.println("\nStarting byte : "+startingByte+"\n End byte "+endByte);
	 
	 return it;
	 //System.out.println("\n"+printMultipleArray(res)+" ");
	 
	}
	private static <T> void printArray(T[] arr) {
    	System.out.println();
    	 for (T element : arr) {
    	        System.out.print(element+" , ");
    	    }
    	
    	 System.out.println();
    }
	
	private static String printMultipleArray(int[][] arr) {
		// 	int[][] res = new int[2][4];

		System.out.println();
		String s="";
		s+="[ ";
		for (int idx2 = 0 ; idx2 <  arr.length ; idx2++) {
			for (int idx =0 ; idx < arr[idx2].length;idx++) {
				if ( (idx % 10) == 0)
					s+="\n";
				s+=" "+arr[idx2][idx]+" , ";
				
		}
				
			
			
		
		}
		s+=" ]";
		return s;
	}
	
	
		
		
	
	
	
	
	private static void printMissingElements(Vector<int[]> arr) {
		System.out.println();
		
		Vector<Integer> bytesTaken = new Vector<>();
		
		for (int[] bArr : arr) {
			for (int bElem : bArr) {
				bytesTaken.add(bElem);
				System.out.println("bElem : "+bElem);
				
			}
		}
		
		//System.out.println(bytesTaken);
		System.out.println();
		for (int i =0 ; i < 256 ; i++) {
			
			if (bytesTaken.contains(i) == false)
				System.out.print(" , "+i);
			   if (i % 10  == 0)
				System.out.println();
				
		}
	
		
	}


	private static void checkBytes_permutation1() {
		Byte[]  key = new Byte[8];
		
		long startTime= System.currentTimeMillis();
		for (int it= 0; it < 32; it++) {
        	key[0] = pos_1[it];  
        	key[1] = pos_2[it];
        	key[2] = pos_3[it];
        	key[3] = pos_4[it];
        	key[4] = pos_5[it];
        	key[5] = pos_6[it];
        	key[6] = pos_7[it];
        	key[7] = pos_8[it];
		
        Permutation1<Byte> perm = new Permutation1<Byte>(key);
       // int count = 0;
        while(perm.hasNext()){
            System.out.println(Arrays.toString(perm.next()));
        }
		}
        long endTime = System.currentTimeMillis();
        long len = endTime-startTime;
        System.out.println("\nTime elapsed "+len+"\n");
        
	}
	private static void checkBytes_permutation() {
		
		Byte[]  key = new Byte[8];
		
		long startTime = System.currentTimeMillis();
				
			for (int it= 0; it < 32; it++) {
            	key[0] = pos_1[it];  
            	key[1] = pos_2[it];
            	key[2] = pos_3[it];
            	key[3] = pos_4[it];
            	key[4] = pos_5[it];
            	key[5] = pos_6[it];
            	key[6] = pos_7[it];
            	key[7] = pos_8[it];

            	
            	
            	// from permutation
            	Permutation.permute(8, key, ',');
            	
              
           }
            	
         long endTime = System.currentTimeMillis();   	
         long resTime = endTime - startTime;
         
         System.out.println("\nTime resultant : "+resTime+"\n");
		
		
		
	
	}
	
	
	public static void main(String[] args) {
		prefix();
		

/*Byte[]  key = new Byte[8];

		
		long startTime = System.currentTimeMillis();
		long endTime,resTime;
		
		List<Byte[]> lArr = new ArrayList<Byte[] >();
		 
			//for (int it= 0; it < 32; it++) {
		for (int it=0 ; it < 1 ; it++) {
            	key[0] = pos_1[it];  
            	key[1] = pos_2[it];
            	key[2] = pos_3[it];
            	key[3] = pos_4[it];
            	key[4] = pos_5[it];
            	key[5] = pos_6[it];
            	key[6] = pos_7[it];
            	key[7] = pos_8[it];
            	lArr = Permutation.permute(8, key, ',');
            	int i=0;
            	
            	
            	Iterator<Byte[]> ite = (Iterator<Byte[]>) lArr.iterator();
            	
            		while (ite.hasNext()) {
            			i++;
            			Byte[] byteArr = (Byte[])ite.next();
            			
            			for (Byte print : byteArr)
            					System.out.print(" , "+String.valueOf(print));
            			System.out.println();
         
            		}
         }
			
			
	   endTime = System.currentTimeMillis();   	
	   resTime = endTime - startTime;
		         
		System.out.println("\nTime resultant : "+resTime+"\n");
				
		Byte[] elements = new Byte[4];
		
		
		
    	// from permutation
    /*	lArr = Permutation.permute(elements.length,elements, ',');
    	Iterator<Byte[]> it = lArr.iterator();
    	while (it.hasNext()) {
    		elements = it.next();
    		for (int i=0 ; i < 4; i++) {
    			System.out.print(intToString(elements[i],8));
    			
    		}
    	
    	}
    	*/
		//prefix();
		
	//	Vector<Integer> v =  getThreeBitsMarkerM(32);
		
       //printThreeBits(32);
		
		/*
		 * 
		 * g,h,i
		 * 
		 */
		
		
		
	
		// ones and ones after 3 bits
		
		// 4bits-> so three bits use 
		// 4 Bits  (2threebtes markers) 8 ones 8 zeros
		// 4 bits below
		
		
	/*base three bits- > 8 , add  10000 (8) to three bits
	base three bits -> 8 , add  11000 (16)  
	base_three_Bits -> 8,  add  11100 (24)
	
		   first 5 bits , needs to be added to bthree bits
	
			add number to three bits, constante? 
			
					
			00000 000
			00000 001
			00000 010
			00000 100
			00000 111
			00000 101
			00000 011
			00000 110
			
			a      b		
			00001 000
			00001 001 c)
			00001 010
			00001 100  
			00001 111
			00001 101  PErcorreu 8 bbytes
			00001 110
			00001 011
			
			
			so marker (001) appears on 5 msb in [8..16 bytes]
			so marker2 (010) appears on 5 msb in [16...24]
			so marker3 (011) appears on 5 msb in [24..32]

					
					4 bits iniciais = 4 bits finais
					
			1		001  b  1   111 a1	 	1 	011	 i 3
			2		010	 c	2	001 a2		2	    101	 j 5
			3		100	 d	4	101 a3     	3	110  k 6
			4		111	 e	7	110 a4		4	111	 l 7
			5		110	 f	6	011 a5		5	100	 m 4
			6		101	 g	5	010 a6		6	010	 n 2
			7		011	 h  3   100 a7 		7	001	 o 1
			
		
					
1		010 2 p		 				
2		111 7 q		 
3		001 1 r  	 
4		100 4 s     
5		110 6 t
6		101 5 w
7		011 3 x
						b=001
						
relação entre valor e posição
			Pos1 () => 001,111,011,010,101
			
			Pos2 =>   010,001,101,111
				
			pos1[0] = pos2[0] ?
			
			
			
			Se tiver desordnado (ou seja nao sequencialmente (3,4,1) (snaõ as posicoes sao iguais)
			
			Pos 1 = 2,5,3,6,7
			Pos 2 = 3,2,5,7,6							Quero permutar Pos1 
			
			For Pos1(2) ={3,2,5,7,6}	// Pos1(1idx) = everything from Pos2 
			For Pos1(5) = {3,2,5,7,6}  // Pos1(2idx) = Everything from Pos 2
			
			
			
			
			For pos1(2) = {2,3,5,6,7} 
			from unorder to order...
			For Pos2(2) = {2,5,3,6,7}
			
			
			indices are 1,2,3,4,5
			            2 3 1 5 4
			            
			            		having 2 -> 1 , having 3->1 , having 1 -> 3,
			            			P1(1idx) => 1-> 2, => P2(1idx) = 2 
			            			P1(2idx) => 2 -> 3 => P2(2idx) =1 
			          
			            1,2,3,4,5
			            
			            1,3,2,4,5		1->1 ; 2-> 3 ; 3-> 2 ; 4->4 ; 5->5 (se num iguais-> num iguais nao fazer nada)
			      		
			          					 
			           
			           1,3,4,2,5
			           
			           1,5,4,2,3
			           
			           
			           
			           
			            		
			            so we equal indices on Pos1 and get the value of Pos2 on that index
			
		sequence(5idx) 
			
			P1(1idx) => P2(2idx) --> 1idx->2idx
					
			P1(2idx) => P2(3idx) 2idx-> 3idx
			
			
			P1(3idx) => P2(1idx) 3idx -> 1idx
			
			troca de indexes.
			
			P1(4idx) => P2(5idx) 4idx -> 5idx
			
			P1(5idx) => P2(idx4) 5 -> 4
			
			
			
			}
			
			Pos1[0] (001)  => Pos2[0]   (001)
			
			se pos1[0] (111) => Pos2[4]  (111)
			
			
			
			
			Pos1(111) => Pos2(X)
			
			
			dont cycle every value (some are repeated (010,111,001))
			
						I can just assign one pos, the other are equal
					 b 		  o			r	
					Pos 1 -> Pos 7 -> Pos 3 (same bits)
						
					
					c  		  n 		p
					Pos 2 -> Pos6 -> Pos 1 
					010		 010 		010
					
					Pos 2 = { 010,101,111}
							 Pos2 Pos6 Pos 1
							
				    pos[0] = b ; pos[0] = o ; pos[0] =r;
					 Pos 1		=		Pos 7	= 	Pos 3
	
							 
					byte[] arr2 = new byte[8];
					byte[] arr3 = new byte[8];
					byte[] arr4 = new byte[8];
					byte[] arr5 = new byte[8];
					byte[] arr6 = new byte[8];
					byte[] arr7 = new byte[8];
					// iniciais, usados para atribuir valor
					
					
					for (int i= 0 ; i < 8; i++) {
						pos[i] =  0b000;
						arr7[i] = 0b001;
						arr2[i] = 0b010
						arr3[i] = 0b011;
						arr4[i] = 0b100;
						arr5[i] = 0b101;
						arr6[i] = 0b111;
						
						
						
						// Todas as possiveis lugares de 001 (i lugares)
 
						
					}
								
								
					
					
						
						
					
					P = {a,b,c,d};
					n=4
					p=2arr[2* 

					4A2 -> n^p
					
				Ou seja os numeros acontecem em posicoes diferentes
				com o mesmo valor (só possivel se houver permutação de elementos)
								
		b=o 
		
		d=m					P1 = {a,b,c,d,e,f,g,h}
		e=l					P2 = {i,j,k,l,n,n,o,p}
		f = k				nP1 = 8
		g = j				nP2 = 8
							p= 3
		h = i			
					Pos b = Pos o?
				Arrrajos = {b,c,a},{d,e,f}
			
							{o,n,p} {m,l,k
		ordem diferente mesmos numeros
					
		Arranjos 
		ou seja ao adiconar um zero anterior ao numero, = 8C8
		
			5 bits
			 00000 000 (0)				1
			 00000 001 (1)	*marker
			 00000 010 (2)	*marker 2 
			 00000 011 (3)	*marker 3
			 00000 100 (4)	
			 00000 101 (5)	
			 00000 110 (6)	
			 00000 111 (7)	  	8
			 00001 000 (8)	
			 00001 001 (9)	
			 00001 010 (10)	
			 00001 011 (11)	
			 00001 100 (12)	
			 00001 101 (13)	
			 00001 110 (14)	
			 00001 111 (15)	
			 00010 000 (16)				16
			 00010 001 (17)	
			 00010 010 (18)	
			 00010 011 (19)	
			 00010 100 (20)	
			 00010 101 (21)	
			 00010 110 (22)	
			 00010 111 (23)	  
			 00011 000 (24)			24
			 00011 001 (25)	
			 00011 010 (26)	
			 00011 011 (27)	
			 00011 100 (28)	
			 00011 101 (29)	
			 00011 110 (30)	
			 00011 111 (31)	   32 
			
			
			
			 } 

			
			*/
		
		
		
        	
        	 
	1 = 01
	2= 10
	3= 11
	 posicao (1,2,3) pos1
	 		  01 10 11 	
	 		  
	 		  
	 		  
	 posicao (3,1,2) pos2
	 		 11 1 10
	 posicao (3,2,1) pos3
	 
	 posicao (1,2,3,4)
	 		
	 
	 
	x^3 + 2x +1 = 0 (eq. polinomial)  {x,1} x cardinality 4 {x,x,x,x,x,1} cardianlyu 6, degree =6 ? 
	
	x*x*x 
	
	Para x=2 2^3
	cardinalyt = sum of X and numbers

cardinality = size of multipset

asserts that the complex solutions of a polynomial equation of degree d always form a multiset of cardinality d.

x^3 + 2x +1 =0 

degree =3
cardinality = 4 {x,x,x,x (one x from 2x),} or {x,x,x,x,x}

problem x ^3 + 2x^1 +1  =0 
solutions of a polynomial equation of degree d always form a multiset of cardinality d. 
	
	expoenent equal = mulitplicty
	proble x^4 + x^3 +1 = 0
	
	
	Solution degree = 4 , 
	
Fundamental theorem of algebra thnik is wrong

	n=3, posicieos = 3
	
	3^3 possible combs
	
	(1,2,3)(3,2,1)(2,1,3)(2,3,2)(3,2,1)(3,1,2) = 6 combs
	
	
	(1,1,2 (1,2,1) (2,1,1)					(1,1,3)(1,3,1)(3,1,1) = 
	
	
	 (1,1,x1)( 1,x1,1)(x1,1,1)(1,1,x2)(1,x2,1)(x2,1,1)
	 
	
	
	
	
	Arranjo simples de n elementos tomados r {\displaystyle r} r a r {\displaystyle r} r
	 
	(2,2,1)     (2,1,2)	(1,2,2)(2,2,3)(2,3,2)(3,2,2)
	
	pos1, pos2, pos 1 +pos3 , pos 
	
	(3,3,2)(2,3,3)(3,2,3)(3,3,1)(1,3,3)(3,1,3)
	(1,1,1)(2,2,2)(3,3,3)
	
	
	Arranjos com repetição = 


   	1,2,255,255} => {1,2,255}  + positions of 255

{255,255,x,x)}
{x,255,255,x}
{x,x,255,255}  
{x,255,x,255}

	
	
		
	
	x = {1,2}
	
a)     {1,x,x,x}	linha 2 , Pos2 = Pos2 todas as posições 2 são iguais 		 
 line2 [x,1,x,x)  	
       (x,x,1,x)  			   
       (x,x,x,1)			 	
      				
      					 	
      							(x,y) coordenadas da matriz
      							num linha X = posicao X
	a) linha 1 , pos 1			num linhas (1) = posicao(1,1)	
	a) linha 2 , pos 2			num linhas (4) = ultima posicao (4,4)  
	a) linha 3,  pos 3
	a) linha 4,  pos 4         posicao(1,1) = num linhas (neste caso 1)
							   posicao(1,2) = num linhas 1 , pos 2
   lin1 {2,x,x,x)  pos1 = linha 1 [2,0,0,0][ 		
   lin2 (x,2,x,x)  pos2 = linha 2
   lin3 (x,x,2,x)  pos3	= linha 3	
   lin4 (x,x,x,2)  pos4 = linha 4	
   
				    
				    
			Matriz =111
					  111
				  3d  011	Matriz triangular superior
			B	  1d  001
   					
   				  4d  100		
   			A	  6d  110	Matriz trianguklar inferior   Btranposta = A
   				  7d  111			
		
		faltam 2,5
				  111
				  010 2d
				  101 5d	 Nao  é simetrica
				  
				  1Symmetric matrix is a square matrix which is equal to its transpose
			
				   
				    				  
	MATRIX A	  row1 11 11 11 11  255
				  row2 11 11 11 10  254 
				  row3 11 11 11 00  252
			MSB	  row4 11 11 10 00 248
				  row5 11 11 00 00 240			MATRIX A INVERTIBLE	
				  row6 11 10 00 00 224			A triangular matrix is invertible if its diagonal entries are non-zero
				  row7 11 00 00 00 192			3. A triangular matrix is invertible if and only if all diagonal entries are nonzero.
				  row8 10 00 00 00 128		
				  
  MATRIX B		  row 1 = 00000000 0
				  row 2 = 00000001 1			MATRIX A E B ARE _UNITRIANGULAR
				  row 3 = 00000011 3			MATRIX A REVERSE OF MATRIX B
						  00000111 7		    MATRIX Atransposed = B
		LSB				  00001111 15			MATRIX Btranposed = A
						  00011111 31			transposed it the reverse for row 1 col1 (on matrix a) = reverse value on matrix b
						  00111111 63
						  01111111 254			MATRIX B NOT NIVERTIBLE
						  
				  
				    00000001 	1
  MATRIX C  		00000010	2			MATRIX C invertible
				    00000100	4		
				    00001000	8
				    00010000	16
				    00100000	32
				    01000000	64
				    10000000	128			matrix C) simetrica (c= ctransosta)  
				    						MATRIX C não é transposta de MATRIX D
				    
MATIX D
					1111110  254
					1111101  125			matrix D) simetrica (D = Dtransposta), não transposta de MATRIX C
					1111011	 123
					1110111	 119 
					1101111  111
					1011111 not used
					0111111127
solutions)				  
				  Assign zeros from MATRIX C to MATRIX AND B
				  
				  00100110 AND with C) (2,4,32) => row 2,row3,row 6 
				  		  
					REVERSE MATRIX C TO GET ZEROS ON A AND B 
		
					
					j = row 
					i = col		
		row=1 col=1  => row3 col1
		row=1 col=2  
		row=1 col=3 1
		row=2 col=1 0
		row=2 col 2 1
		row=2 col 3 0
		row=3 col 1 1
		row 3 col2  0
		row 3 col3  1
		 
		
		
		A and B are not diagonal matrices (diagonal must be 0)
		
		A igual a transposta de B
		Bt = A
		A = At
		é simetrica
		
		an A  matrix é simetrica  se A=Atrans o que significa aij=aji
		
		E = [1 0 0 ]   F = [1 1 1]  E F  = [ 1 1 1 ]			
		    [1 1 0 ]       [0 1 1]         [ 1 2 2 ]
		    [1 1 1 ]       [0 0 1]         [ 1 2 3 ]
		
	F E =  [ 3 2 1]
		   [ 2 2 1]			EF  is symetric = EF = (EF)T 
		   [ 1 1 1]         FE  = symetric = (FE)T = FE
		   					E not symetric
		   					F not symetric
		   					EF+FE 
		   					
		   [3 2 1]	[1 1 1]				[ d  a12  a22 ]
		   [2 2 1] +[1 2 2] =>  		[a12 d1   a21 ]    
		   [1 1 1]	[1 2 3 				[a22 a21  d2  ]
		   
		   d = 3+1
		   d1 = 2+2
		   d2 = 4
		   
		   a12 = 3					
		   a22=1+1 					
		   a21= 1+2					
		   
		   Sum = equals multiplication
		   
		   2x = x+x
		   
		   consigo converter matrix para mais simples (sendo simetrica)
		   
		   a12 + a12  =  2 * (a12) duas casas =  
		   
		   X = a12= 3   Y = a22 = 2   a21 = W = 3
		   
		   a12 = a21 
		   
		   
		   [ d X Y ]  [ d d1 d2 ] [X Y] [1]
		   [ X d1 X]  				
		   { Y X d2]
		   
		   X- > (1,2) (2,1) (2,3) (3,2)
		   Y -> (1,3) (3,1)
		   
		  
		  [d1    ]
		  [	d2   ]							
		  [	  d3 ] equals in linear to ? 
		   
		   [ 1   ]
		   [  2  ]		(1,1) = 1   (2,2) = 2 (3,3) = 8 ,,transformar uma matriz simetrica num matriz 1x3 		
		   [   8 ]
		   
		   a22 = a12 =>     a12 + (1,0) 
		   a33 = a13 => 	a33 -(2,0) 
		   
		   [ 1 0 0 ]	
		   [ 0 2 0 ] + 	POS 22 = POS 12
		   { 0 0 8]
		   
		   Object temp = array[a][b + 1];
		   array[a][b + 1] = array[a + 1][b];
			array[a + 1][b] = temp; 
		   
		   (2,1) swamp (1,2)				   
		   (3,3) swamp (1,3)
		   
		   
		   a=2 b=1
		   
		   swamp row 2 with row1 with 
		   one matrix?
		   [ 1 0 0 ]
		   [ 0 2 0 ]
		   
		   
		   
		   
		   
		   				   	
		 The sum and difference of two symmetric matrices is again symmetric
		 
		 
		  		(A + B)T = AT + BT:    
				(1,2) = ( (1,2) + (		  		
		  		    arr[i] = (arr[i] + arr[j]) - (arr[j] = arr[i]); 
		  		    // FROM https://stackoverflow.com/questions/13766209/effective-swapping-of-elements-of-an-array-in-java
		  		    
		  		                            
		The product of two triangular matrices is triangular
		A triangular matrix is invertible if its diagonal entries are non-zero
		
		
		
		Matriz A,
		AB=BA = In , então A é invertivel , sendo A Lower triangular matrix e B upper triangular matrix
		então factorizacao possivel,
		
		a)			b)						Pos1 = linha 1
		[1,0,0]	[0,0,1]		
		[1,1,0] [1,0,0]   					
		[1,1,1} (1,1,0]						
		
		
		if element of matrix is zero, no need to calculate multiplication
		
		
									
											
		Lower triangle = {1, 0 0]	Lower e upper  								
						  0  1 0 
						  0  0 1
		 						
	A)	A pos2 = B pos2, visto que são quadradas e 
	
	quais os elementos que usam a a) pos2 linha 1 = b)  inha 2 pos 2,  
		A pos2 = 0 
	
	 a)linha 1 pos2 b) linha 2, pos1 
	 a)linha 1 pos2 b) linha 2 pos 2   =a) linha1 b) linha2 ,pos mesma
	 a) linha 1 pos2 b) linha 2 pos 3  			
				
		(0,1 (0,0) (0,
		
		getting pos2 , 
		escolhi pos2 (a), linha 1), logo obtem-se linha 2
        escolhi pos1 (a) , linha1  ), linha 1		 
		combinar 1linha [1,0,0] 2linha [1,0,0]
				[
	 	pos2 linha 1 = linha 2 pos 1   +  pos2 linha 1 = 
		[ 
	
	row{1][1][1] * col[ = num
	    
	dot product
		
	a)	linha1,pos2,pos3 , linha 2 pos3,
	b)  linha 1 pos1,pos2,pos3 , linha 2 pos 2,3,linha 3 pos 3
		
		 a matrix decomposition or matrix factorization is a factorization of a matrix into a product of matrices
		
		
		a) * b) = c)
		
		a = bt
		at = b 
		
		visto ser invertivel
		he LU decomposition factorizes a matrix 
		into a lower triangular matrix L and an upper triangular matrix
		
		
		so we have lower, upper triangle (a), b)) 
		and want to find thte (origianl matrix)

		X = LowerTraingle*UpperTriangule
		X = a) * b)
		
		



		tranopse of a) = b)
		transpose of b) = a)
		
		inverse fof a) = b)
		
	y the LU decomposition algorithm, an invertible matrix
	 may be written as the product of a lower triangular matrix L and an upper triangular matrix U if
		
		
		(byte1,byte2)
		(byte1,byte1)
		(byte2,byte2)
		(byte2,byte1)
		
		byte2 = Transposta de (byte1) 
			
			


							
							
							
							
						
						
						igualando a posicao a 5 (arbitrario) a (3,1, arbitrario), quere-se as coordenadas dos vectores
						posicao(3,1) = 5 (magnitude)
						x=3 y=1
						sqr(x^2 + y^2) = 5 (5 sendo magnitude, calcular as coordenadas dos vectors 
						
						
						
						
									
																	
								
								 
								 
								Change tuples by matrices 
								posicao(2,1) = posicao(1,1) + pos(1,1) = 1+1 = 2
								posicao(3,1) = posicao(2,2) + pos(1,1) = (3,3)
								posicao(4,1) = posicao(3,3) + pos(1,1) =(4,4)
								
							 	(1,1) = [1 1 ]
									pos (1,1) + pos(1,1) = [1 1] + [1 1] = [2 2]; 					
	 							(2,1) => [ 2 1 ]	
							 
(a+b) trans = atrans + btrans
							  
b)
			
			[b,0,0,0}		USED	diagonal matrix
        	[0,b,0,0]	 3 bits -> zero em primeiro 
        	[0,0,b,0]	 2 bits
        	[0,0,0,b]    1bits
        		 
        		
				3combs
			[0,0,b,b]	2 bits
			[0,b,0,b}   3bits
			{b,0,0,b]   USED
			[0,b,b,0]    3 bits
			{b,0,b,0]	USED
			[b,b,0,0] 	USED
			
				3combs
			(0,b,b,b)	3bits
			(b,b,b,0)  USED
			(b,0,b,b)  USED
			(b,b,0,b) USED

				 
	 		    
	 		  
