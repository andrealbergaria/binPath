 private static void printMissingElems() {
        	

        	//o) = m) + 1111
        	//n) = o) + m)
        	//o= n+m
        	
        	int[] a = {1,2,3,4,5,6,7,8};
        	ArrayList al = new ArrayList();
        	
        	System.out.println();
        	for (int itM=0; i < m.length; i++) {
        		int m = m[itM];
        		al.add(new Integer(m));
        		
        		System.out.print("0000 "+m[itM]+"("+m+")");
        		
        		int n = m[itM]+0b1111;
        		
        		al.add(new Integer(n));
        		System.out.println(x+" 0000 ("+n+")");
        		
        		int o = n+m ;
        		al.add(new Integer(o));
        		System.outl.println(m[itM] + " "+m[itM]+ " ("+o+")");        
        		}
        		System.out.println();
        		for (int i=0 ; i < 24; i++) {
        			if (!al.contains(new Integer(i)))
        					System.out.print(" "+i+" , ");
        }
        
}
        */

/*
		256 *8 = 2048
		
		Para 2 bytes, apenas uma posicao é precisa
		primeiroByte[1.256] & primeiroByte[1.256]
		
		numero total de mudanças de ordem
		4
		
		para arranjos 2 ^ 2 = 4  ( se o segundo byte for igual ao 1)
		 					=  
		if same element , 
		(1,1)
		(0,1)
		(0,0)
		(1,0)
		
		(3,2,2)		
		(1,2,3)  => 3*256 (todas as possiveis combinações)
		(1,1,3)
		
		
		Se 3 belongs to i, and 2 belongs to i , 1 belongs to 1 (always)
		or 3 = 2 = 1
		
		obter todas as combinações , do conjunto em que tenha 3
		quais os limites?
		1 <= 3 <= 8 ?

		
		
		thirdByte[1..3] oneByte[1..3] oneByte[1..3]
		everything equal
		
		i = {1,2,3} (equals the elements of set)
		
		thirByte = oneByte = secondByte

		
		 
		
		 
				
		
		}
		 
		
		
		
		
		
		 
		
		
		
		
			public static byte[] pos_1 = { 1 , 9 , 17 , 25 , 33 , 41 , 49 , 57 , 65 , 73 , 81 , 89 , 97 , 105 , 113 , 121 ,  (byte) 129 ,  (byte) 137 ,  (byte) 145 ,  (byte) 153 ,  (byte) 161 ,  (byte) 169 ,  (byte) 177 ,  (byte) 185 ,  (byte) 193 ,  (byte) 201 ,  (byte) 209 ,  (byte) 217 ,  (byte) 225 ,  (byte) 233 ,  (byte) 241 ,  (byte) 249 }; 
	public static byte[] pos_2 = { 2 , 10 , 18 , 26 , 34 , 42 , 50 , 58 , 66 , 74 , 82 , 90 , 98 , 106 , 114 , 122 ,  (byte) 130 ,  (byte) 138 ,  (byte) 146 ,  (byte) 154 ,  (byte) 162 ,  (byte) 170 ,  (byte) 178 ,  (byte) 186 ,  (byte) 194 ,  (byte) 202 ,  (byte) 210 ,  (byte) 218 ,  (byte) 226 ,  (byte) 234 ,  (byte) 242 ,  (byte) 250 }; 
	public static byte[] pos_3 = { 3 , 11 , 19 , 27 , 35 , 43 , 51 , 59 , 67 , 75 , 83 , 91 , 99 , 107 , 115 , 123 ,  (byte) 131 ,  (byte) 139 ,  (byte) 147 ,  (byte) 155 ,  (byte) 163 ,  (byte) 171 ,  (byte) 179 ,  (byte) 187 ,  (byte) 195 ,  (byte) 203 ,  (byte) 211 ,  (byte) 219 ,  (byte) 227 ,  (byte) 235 ,  (byte) 243 ,  (byte) 251 };
	public static byte[] pos_4 = { 4 , 12 , 20 , 28 , 36 , 44 , 52 , 60 , 68 , 76 , 84 , 92 , 100 , 108 , 116 , 124 ,  (byte) 132 ,  (byte) 140 ,  (byte) 148 ,  (byte) 156 ,  (byte) 164 ,  (byte) 172 ,  (byte) 180 ,  (byte) 188 ,  (byte) 196 ,  (byte) 204 ,  (byte) 212 ,  (byte) 220 ,  (byte) 228 ,  (byte) 236 ,  (byte) 244 ,  (byte) 252 }; 
	public static byte[] pos_5 = { 5 , 13 , 21 , 29 , 37 , 45 , 53 , 61 , 69 , 77 , 85 , 93 , 101 , 109 , 117 , 125 ,  (byte) 133 ,  (byte) 141 ,  (byte) 149 ,  (byte) 157 ,  (byte) 165 ,  (byte) 173 ,  (byte) 181 ,  (byte) 189 ,  (byte) 197 ,  (byte) 205 ,  (byte) 213 ,  (byte) 221 ,  (byte) 229 ,  (byte) 237 ,  (byte) 245 ,  (byte) 253 }; 
	public static byte[] pos_6 = { 6 , 14 , 22 , 30 , 38 , 46 , 54 , 62 , 70 , 78 , 86 , 94 , 102 , 110 , 118 , 126 ,  (byte) 134 ,  (byte) 142 ,  (byte) 150 ,  (byte) 158 ,  (byte) 166 ,  (byte) 174 ,  (byte) 182 ,  (byte) 190 ,  (byte) 198 ,  (byte) 206 ,  (byte) 214 ,  (byte) 222 ,  (byte) 230 ,  (byte) 238 ,  (byte) 246 ,  (byte) 254 };   
	public static byte[] pos_7 = { 7 , 15 , 23 , 31 , 39 , 47 , 55 , 63 , 71 , 79 , 87 , 95 , 103 , 111 , 119 , 127 ,  (byte) 135 ,  (byte) 143 ,  (byte) 151 ,  (byte) 159 ,  (byte) 167 ,  (byte) 175 ,  (byte) 183 ,  (byte) 191 ,  (byte) 199 ,  (byte) 207 ,  (byte) 215 ,  (byte) 223 ,  (byte) 231 ,  (byte) 239 ,  (byte) 247 ,  (byte) 255 };  
	public static byte[] pos_8 = { 8 , 16 , 24 , 32 , 40 , 48 , 56 , 64 , 72 , 80 , 88 , 96 , 104 , 112 , 120 , (byte) 128 ,  (byte) 136 ,  (byte) 144 ,  (byte) 152 ,  (byte) 160 ,  (byte) 168 ,  (byte) 176 ,  (byte) 184 ,  (byte) 192 ,  (byte) 200 ,  (byte) 208 ,  (byte) 216 ,  (byte) 224 ,  (byte) 232 ,  (byte) 240 ,  (byte) 248 ,  (byte) 256 };
		
			distancia entre pares-> 1
			pairs first bit  -> 8 de zeros , 8 pares de uns (numero de zeros e uns é sempre igual para todas as iterações)
			4 pairs distancia -> 2 (snd bit)
			2 paires -> distancia 4;

			fifth bit? aumentei o numero de bits, oo 4 bit foi alterado (passou a ser  2pair, cada par 8 , o first bit passou a ter 16pares)
			
			fifth bit -> 1 pair intervalo 0
			 
			
			/* 	First bit
			 * idx 1,3,5,7,9,11 = 0
			 * idx 2,4,6,8,10,12 = 1,  (separated by 2)
			 * 	+1
			 
			 *  second bit
			 * idx 1,2,5,6,9,10 = 0
			 * idx 3,4,7,8,11,12,15,16 = 1
			 * 
			 *    +2
			 *    Third bit
			 * idx 1,2,3,4,9,10,11,12 = 0
			 * idx 5,6,7,8 = 1
			 * 
			 *  +4
			 */
			
			/* Second bit = firstbit(0,1) *2
					 * => firstbit(0,1) *2  
					 *
			relationship betwen first bit and second bit 
			trying only with ones (use cycle to iterate index and assign ones
			zeros are already taken by java
			
			first bit
			2,4,6,8		10,12,15,16
			
		
			
				// Set first bit to 1
				// set second bit to 1
				// set third bit to 1
			
				
			3,4,7,8,	11,12,15,16
		
			third bit
			5,6,7,8,	13,14,15,16		
	  	 
			 
			 
			  
			  
			*/
		
	//	int[] another = new int[16];
		
		
		// skip counting zeros, just assign arrays to 1..the others are 0
	/*	
		
		n) = m) + 1111 + m)		
			
			 0000 0111 + 0000 1111  + 0000 0111
		
	set 2    set 1	
	m)	0000 0111	7		
		0000 0011	3
		0000 0101   5
		0000 0001	1		 (1,2,3,4,5,6,7,8)
		0000 0110	6		+1111 +1111 +1111  	
		0000 0010	2			
		0000 0100	4
		0000 1000  8
		
		 
		112   7				119-112 = 7d 
	n)	0111 0111 119 		we subtract the number 
							from the 1set of binaries to
							the number (119d-0111b (7d) on 7 on m)
							and another example 51d-011 on 3 on  m) 
		0011 0011 51
		0101 0101 85
		0001 0001 17
		0110 0110 102
		0010 0010 34 
		0100 0100 68 
		0000 1000 8						
		
o)		0111 0000 112					set 1 = tem de ser igual a (1,2,3,4,5,6,7,8)  ou tudo a zeros?
										set 2=   (1,2,3,45,5,6,7,8) ou zeros ?
		0011 0000 48
		
		0101 0000 80
		0001 0000 16					1 = (1,2,3,4,5,6,7) 	?						0  = zeros??
		0110 0000 96					
		0010 0000 32					(1,1) (0,1) (1,0) (0 , 0) => Todas as ordens possiveis
		0100 0000 64				
		1000 0000 128						
		
		
												0,17,34,51,68,85,102,119
		o) = m) + 1111
		n) = o) + m)
								minus -     0  1  2  3  4  5  6  7  m)  ( 0, 1)
	
	
    
    
											    0,16,32,48,64,80,96,112 o) (1,0)
		
								divide_by_16 
								
												0,1,2,3,4,5,6,7					
			
				shift esquerdo = dividir por 16
				k= h)#1 / g)#1 = 16  
				k= h)#2 / g)#2 =  16
				k= h)#3 / g)#3  =  16
				
					f(g) = h)#1 / k , com k= 16
							
					i#1-g#1 = h#1
				
					f(g) = (i#1-g#1) / k
								

				
				a constante é 16 neste caso (para outros bits serao o mesmo)
				
				
				
								
g)  0000 1000	8d							
	0000 1001   9d
	0000 1010   10d
	0000 1011   11d
	0000 1100	12d
	0000 1101   13d
	0000 1110   14
	0000 1111   15
	0000 1111  16
	
	
	
h)							128 = 8*16   ( 8d * )
	1000 0000  8k = 128 , k=  128 / 8 => 16d = 8d
	1001 0000  144 = 9K = k= 144/9 => 16					
	1010 0000	160 = 10k = 16	 										
	1011 0000
	1100 0000
	1101 0000
	1110 0000
	1111 0000
	
	 
	
i)
	1000 1000  		i#1 = g#1+h#1 
	1001 1001  		i#2 = g#2+h#2   
	1010 1010  		 	
	1011 1011
	1100 1100
	1101 1101
	1110 1110
	1111 1111
	
												
					
		linha=8 bytes
		col = 2
												
												
					(1,1,1)(1,1,0)(1,0,1)(0,1,1)(0,0,1)(0,1,0)(0,1,0)(000)		
													
						0 = zeros?	1= (1,2,3,4,5,6,7) or 1 = (1,2,3)			
												

		bits iniciais 4 , maximum => 2 positions
		bits iniciais 8 , maximum => (2^3) 3 posicoes 		
		bits iniciais 16 , maximum => (2^4) 4 positions
		bit  iniciais 32 , maximum -> 5 positions 
		bits iniciais 256 , maximum => 8 positions 
		bits iniciais 512 -> maximum => 9 positions 
		bytes iniciais 4294967296 -> 32 positions?
				
				ou seja vai diminuindo pela posicioes.....(menos 2vezes)
		
   4    3   2   1 				
b)	1	1	1	1 
	0	1   1	1 
	1	0	1	1  
	0	0	1	1  
	1	1	0	1    
	0	1	0	1		4 coluna = 3 coluna de a)   
7	1	0	0	1		3 coluna = 2 coluna de a)
	0	0	0   1 		2 coluna = 1 coluna de a)
	1	1	1	0		 
	0	1   1   0    
	1	0	1	0
	0	0	1	0
	1	1	0	0		
	0	1	0	0
15	1	0	0	0		 
	0	0	0	0
		
	
	(4,3,2) ->  2threebits
	(1,2,3) -> nada
	 
	8 bits-> 32
	9 bits-> 64
	10 bits ->128
	11 bits -> 256
	12 bits -> 512
	13 bits -> 1024
	14 bits -> 2048
    15 bits -> 4096										
	16 bits -> (anterior ) * 2  
			-> 8192 * (1.....8192 of three bits)
					
					7 * 8192
					57344
					
		3bits ->8 combinações
		
		threeBits(7) = #8
		threeBits(15) = #8
	
	
	poupar 3 bits pois ao sempre igaugis em todas as posicoes
	
		threeBits = 16 elemets
	3 bits -> 1 * threeBits(7); => 8
	
	4 bits -> threeBits (7,15)  => 2*8 // 2*8
	
	5 bits -> threeBits (7,15,23,31) // 4*8
	
	6 bits -> threeBits (7,15,23,31,39,47,55,63) //8 * 8 

	
	//-- three marker bits
	
	5 bits- > (4bits,23,31)
	6 bits-> (5bits,39,47,55,63)
	7 bits-> (6bits,71,79,87,95,103,111,119,127)
	
	256 bits have 3 bits initials 
	
	/*Percorrer o mesmo ciclo e adicioainar 7
	
	15    = 0b1111
	23    = 0b10111 (15+7)
	31    = 0b11111 (23+7)
	
	byte1
	0b0 0 0		
	0b0 0 1			
	0b0 1 0		
	0b0 1 1		
	0b1 0 0		
	0b1 0 1		
	0b1 1 0		
	0b1 1 1		
				
					
	byte2
	0b0 0 0
	0b0 0 1
	0b0 1 0
	0b0 1 1
	0b1 0 0
	0b1 0 1
	0b1 1 0
	0b1 1 1 	 
	
	since they are equal to the first byte, one can assign without cycle
	
	3bits , All combinations = 2^3 = 8 bits
	4bits , All combinations = 2^4 = 16bits
	5bits , All combinations = 2^5 = 4 bytes
	6bits , All combinations = 2^6 = 8 bytes
	7bits , All combinations = 2^7 = 128combs
	8bits , All combinations = 2^8 =  256 combs
	256bits , All combinations = 2^256
	
	1)00 10 01 11 2^8 = 256 combs 2) 11 01 10 01 = 256comb 2^8
	 
		se 2^8 entao todas as combinações no primeiro byte
		de 1) são iguais ao 2)
			
			
			 o prmeiro byte vai ser semptre [1...256]
			 o segundo byte vai ser sempre [1..256]
	 para 2 bytes
	 primeiroByte[1...256]	primeirobyte[1...256]
	 segundo byte[1...256] primeirobytye[1...256]
	 segundobyte[1...256] segundobyte[1...256]
	primeriobytye[1..256] segundo[1...256]
	
	n=2 , p =2
	
	{p,s} => {ps,sp,ss,pp}
	 
	n={1,2,3,4}
	p= {4}
	
	it a = 2^8
	arr[a][a] = [1..256][1..256][1..256]
	aplus = 2^8*2
	
	arr[1plus[
	1 -> index da array
	Para 1 byte
	[1....256]
	Para 2 bytes 
	2->index da array = position 2
	[1...256] [1...256] // concat
	1) = anterior
	2) = anterior
	3) = anterior
	
	
	
		
		
	
	//int endByte=4;
	//int endByte=0;
	//for (int startByte=0; startByte < 32; startByte+=4) {
	//		it+=printSixTeen(res,startByte,endByte);
	//		endByte+=4;
	//	}
	//}
	int[][] res = new int[32][32];
	int sizeByte[] = {  0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 254 , 255 }; 
	for (int pos = 0 ; pos < 32; pos++) {
		for (int pos2 = 0; pos2 < 32; pos2++) {
			res[pos][pos] = sizeByte; 
		}
	}
	
	/*printSixTEen(res,0,4);
	printSixTeen(res,4,8);
	printSixTeen(res,8,12);
	printSixTeen(res,12,16);
	printSixTeen(res,16,20);
	printSixTeen(res,20,24);
	printSixTeen(res,24,28);
	printSixTeen(res,24,28);
	*/
	
	
	

     
	
	
		//printArray(arr);
		//printMultipleArray(res);
	
	
	// Return iterations
	private static int printSixTeen(int[][] res,int startingByte,int endByte) {
		
		int it=1;
		
		System.out.println();
	 for (int i =startingByte; i < endByte; i++) {
		 	 for (int i3 = 0 ; i3 < 256; i3++) {
	 	 		res[i][i] = i3;
	 	 		it++;
			 }
		 }
	 
	 
	 
	 System.out.println("\nStarting byte : "+startingByte+"\n End byte "+endByte);
	 
	 return it;
	 //System.out.println("\n"+printMultipleArray(res)+" ");
	 
	}
	private static <T> void printArray(T[] arr) {
    	System.out.println();
    	 for (T element : arr) {
    	        System.out.print(element+" , ");
    	    }
    	
    	 System.out.println();
    }
	
	private static String printMultipleArray(int[][] arr) {
		// 	int[][] res = new int[2][4];

		System.out.println();
		String s="";
		s+="[ ";
		for (int idx2 = 0 ; idx2 <  arr.length ; idx2++) {
			for (int idx =0 ; idx < arr[idx2].length;idx++) {
				if ( (idx % 10) == 0)
					s+="\n";
				s+=" "+arr[idx2][idx]+" , ";
				
		}
				
			
			
		
		}
		s+=" ]";
		return s;
	}
	
	
		
		
	
	
	
	
	private static void printMissingElements(Vector<int[]> arr) {
		System.out.println();
		
		Vector<Integer> bytesTaken = new Vector<>();
		
		for (int[] bArr : arr) {
			for (int bElem : bArr) {
				bytesTaken.add(bElem);
				System.out.println("bElem : "+bElem);
				
			}
		}
		
		//System.out.println(bytesTaken);
		System.out.println();
		for (int i =0 ; i < 256 ; i++) {
			
			if (bytesTaken.contains(i) == false)
				System.out.print(" , "+i);
			   if (i % 10  == 0)
				System.out.println();
				
		}
	
		
	}


	private static void checkBytes_permutation1() {
		Byte[]  key = new Byte[8];
		
		long startTime= System.currentTimeMillis();
		for (int it= 0; it < 32; it++) {
        	key[0] = pos_1[it];  
        	key[1] = pos_2[it];
        	key[2] = pos_3[it];
        	key[3] = pos_4[it];
        	key[4] = pos_5[it];
        	key[5] = pos_6[it];
        	key[6] = pos_7[it];
        	key[7] = pos_8[it];
		
        Permutation1<Byte> perm = new Permutation1<Byte>(key);
       // int count = 0;
        while(perm.hasNext()){
            System.out.println(Arrays.toString(perm.next()));
        }
		}
        long endTime = System.currentTimeMillis();
        long len = endTime-startTime;
        System.out.println("\nTime elapsed "+len+"\n");
        
	}
	private static void checkBytes_permutation() {
		
		Byte[]  key = new Byte[8];
		
		long startTime = System.currentTimeMillis();
				
			for (int it= 0; it < 32; it++) {
            	key[0] = pos_1[it];  
            	key[1] = pos_2[it];
            	key[2] = pos_3[it];
            	key[3] = pos_4[it];
            	key[4] = pos_5[it];
            	key[5] = pos_6[it];
            	key[6] = pos_7[it];
            	key[7] = pos_8[it];

            	
            	
            	// from permutation
            	Permutation.permute(8, key, ',');
            	
              
           }
            	
         long endTime = System.currentTimeMillis();   	
         long resTime = endTime - startTime;
         
         System.out.println("\nTime resultant : "+resTime+"\n");
		
		
		
	
	}
	
	
	public static void main(String[] args) {
		prefix();
		

/*Byte[]  key = new Byte[8];

		
		long startTime = System.currentTimeMillis();
		long endTime,resTime;
		
		List<Byte[]> lArr = new ArrayList<Byte[] >();
		 
			//for (int it= 0; it < 32; it++) {
		for (int it=0 ; it < 1 ; it++) {
            	key[0] = pos_1[it];  
            	key[1] = pos_2[it];
            	key[2] = pos_3[it];
            	key[3] = pos_4[it];
            	key[4] = pos_5[it];
            	key[5] = pos_6[it];
            	key[6] = pos_7[it];
            	key[7] = pos_8[it];
            	lArr = Permutation.permute(8, key, ',');
            	int i=0;
            	
            	
            	Iterator<Byte[]> ite = (Iterator<Byte[]>) lArr.iterator();
            	
            		while (ite.hasNext()) {
            			i++;
            			Byte[] byteArr = (Byte[])ite.next();
            			
            			for (Byte print : byteArr)
            					System.out.print(" , "+String.valueOf(print));
            			System.out.println();
         
            		}
         }
			
			
	   endTime = System.currentTimeMillis();   	
	   resTime = endTime - startTime;
		         
		System.out.println("\nTime resultant : "+resTime+"\n");
				
		Byte[] elements = new Byte[4];
		
		
		
    	// from permutation
    /*	lArr = Permutation.permute(elements.length,elements, ',');
    	Iterator<Byte[]> it = lArr.iterator();
    	while (it.hasNext()) {
    		elements = it.next();
    		for (int i=0 ; i < 4; i++) {
    			System.out.print(intToString(elements[i],8));
    			
    		}
    	
    	}
    	*/
		//prefix();
		
	//	Vector<Integer> v =  getThreeBitsMarkerM(32);
		
       //printThreeBits(32);
		
		/*
		 * 
		 * g,h,i
		 * 
		 */
		
		
		
	
		// ones and ones after 3 bits
		
		// 4bits-> so three bits use 
		// 4 Bits  (2threebtes markers) 8 ones 8 zeros
		// 4 bits below
		
		
	/*base three bits- > 8 , add  10000 (8) to three bits
	base three bits -> 8 , add  11000 (16)  
	base_three_Bits -> 8,  add  11100 (24)
	
		   first 5 bits , needs to be added to bthree bits
	
			add number to three bits, constante? 
			
					
			00000 000
			00000 001
			00000 010
			00000 100
			00000 111
			00000 101
			00000 011
			00000 110
			
			a      b		
			00001 000
			00001 001 c)
			00001 010
			00001 100  
			00001 111
			00001 101  PErcorreu 8 bbytes
			00001 110
			00001 011
			
			
			so marker (001) appears on 5 msb in [8..16 bytes]
			so marker2 (010) appears on 5 msb in [16...24]
			so marker3 (011) appears on 5 msb in [24..32]

					
					4 bits iniciais = 4 bits finais
					
			1		001  b  1   111 a1	 	1 	011	 i 3
			2		010	 c	2	001 a2		2	    101	 j 5
			3		100	 d	4	101 a3     	3	110  k 6
			4		111	 e	7	110 a4		4	111	 l 7
			5		110	 f	6	011 a5		5	100	 m 4
			6		101	 g	5	010 a6		6	010	 n 2
			7		011	 h  3   100 a7 		7	001	 o 1
			
		
					
1		010 2 p		 				
2		111 7 q		 
3		001 1 r  	 
4		100 4 s     
5		110 6 t
6		101 5 w
7		011 3 x
						b=001
						
relação entre valor e posição
			Pos1 () => 001,111,011,010,101
			
			Pos2 =>   010,001,101,111
				
			pos1[0] = pos2[0] ?
			
			
			
			Se tiver desordnado (ou seja nao sequencialmente (3,4,1) (snaõ as posicoes sao iguais)
			
			Pos 1 = 2,5,3,6,7
			Pos 2 = 3,2,5,7,6							Quero permutar Pos1 
			
			For Pos1(2) ={3,2,5,7,6}	// Pos1(1idx) = everything from Pos2 
			For Pos1(5) = {3,2,5,7,6}  // Pos1(2idx) = Everything from Pos 2
			
			
			
			
			For pos1(2) = {2,3,5,6,7} 
			from unorder to order...
			For Pos2(2) = {2,5,3,6,7}
			
			
			indices are 1,2,3,4,5
			            2 3 1 5 4
			            
			            		having 2 -> 1 , having 3->1 , having 1 -> 3,
			            			P1(1idx) => 1-> 2, => P2(1idx) = 2 
			            			P1(2idx) => 2 -> 3 => P2(2idx) =1 
			          
			            1,2,3,4,5
			            
			            1,3,2,4,5		1->1 ; 2-> 3 ; 3-> 2 ; 4->4 ; 5->5 (se num iguais-> num iguais nao fazer nada)
			      		
			          					 
			           
			           1,3,4,2,5
			           
			           1,5,4,2,3
			           
			           
			           
			           
			            		
			            so we equal indices on Pos1 and get the value of Pos2 on that index
			
		sequence(5idx) 
			
			P1(1idx) => P2(2idx) --> 1idx->2idx
					
			P1(2idx) => P2(3idx) 2idx-> 3idx
			
			
			P1(3idx) => P2(1idx) 3idx -> 1idx
			
			troca de indexes.
			
			P1(4idx) => P2(5idx) 4idx -> 5idx
			
			P1(5idx) => P2(idx4) 5 -> 4
			
			
			
			}
			
			Pos1[0] (001)  => Pos2[0]   (001)
			
			se pos1[0] (111) => Pos2[4]  (111)
			
			
			
			
			Pos1(111) => Pos2(X)
			
			
			dont cycle every value (some are repeated (010,111,001))
			
						I can just assign one pos, the other are equal
					 b 		  o			r	
					Pos 1 -> Pos 7 -> Pos 3 (same bits)
						
					
					c  		  n 		p
					Pos 2 -> Pos6 -> Pos 1 
					010		 010 		010
					
					Pos 2 = { 010,101,111}
							 Pos2 Pos6 Pos 1
							
				    pos[0] = b ; pos[0] = o ; pos[0] =r;
					 Pos 1		=		Pos 7	= 	Pos 3
	
							 
					byte[] arr2 = new byte[8];
					byte[] arr3 = new byte[8];
					byte[] arr4 = new byte[8];
					byte[] arr5 = new byte[8];
					byte[] arr6 = new byte[8];
					byte[] arr7 = new byte[8];
					// iniciais, usados para atribuir valor
					
					
					for (int i= 0 ; i < 8; i++) {
						pos[i] =  0b000;
						arr7[i] = 0b001;
						arr2[i] = 0b010
						arr3[i] = 0b011;
						arr4[i] = 0b100;
						arr5[i] = 0b101;
						arr6[i] = 0b111;
						
						
						
						// Todas as possiveis lugares de 001 (i lugares)
 
						
					}
								
								
					
					
						
						
					
					P = {a,b,c,d};
					n=4
					p=2arr[2* 

					4A2 -> n^p
					
				Ou seja os numeros acontecem em posicoes diferentes
				com o mesmo valor (só possivel se houver permutação de elementos)
								
		b=o 
		
		d=m					P1 = {a,b,c,d,e,f,g,h}
		e=l					P2 = {i,j,k,l,n,n,o,p}
		f = k				nP1 = 8
		g = j				nP2 = 8
							p= 3
		h = i			
					Pos b = Pos o?
				Arrrajos = {b,c,a},{d,e,f}
			
							{o,n,p} {m,l,k
		ordem diferente mesmos numeros
					
		Arranjos 
		ou seja ao adiconar um zero anterior ao numero, = 8C8
		
			5 bits
			 00000 000 (0)				1
			 00000 001 (1)	*marker
			 00000 010 (2)	*marker 2 
			 00000 011 (3)	*marker 3
			 00000 100 (4)	
			 00000 101 (5)	
			 00000 110 (6)	
			 00000 111 (7)	  	8
			 00001 000 (8)	
			 00001 001 (9)	
			 00001 010 (10)	
			 00001 011 (11)	
			 00001 100 (12)	
			 00001 101 (13)	
			 00001 110 (14)	
			 00001 111 (15)	
			 00010 000 (16)				16
			 00010 001 (17)	
			 00010 010 (18)	
			 00010 011 (19)	
			 00010 100 (20)	
			 00010 101 (21)	
			 00010 110 (22)	
			 00010 111 (23)	  
			 00011 000 (24)			24
			 00011 001 (25)	
			 00011 010 (26)	
			 00011 011 (27)	
			 00011 100 (28)	
			 00011 101 (29)	
			 00011 110 (30)	
			 00011 111 (31)	   32 
			
			
			
			 } 

			
			*/
		
		
		
        	
        	 
	1 = 01
	2= 10
	3= 11
	 posicao (1,2,3) pos1
	 		  01 10 11 	
	 		  
	 		  
	 		  
	 posicao (3,1,2) pos2
	 		 11 1 10
	 posicao (3,2,1) pos3
	 
	 posicao (1,2,3,4)
	 		
	 
	 
	x^3 + 2x +1 = 0 (eq. polinomial)  {x,1} x cardinality 4 {x,x,x,x,x,1} cardianlyu 6, degree =6 ? 
	
	x*x*x 
	
	Para x=2 2^3
	cardinalyt = sum of X and numbers

cardinality = size of multipset

asserts that the complex solutions of a polynomial equation of degree d always form a multiset of cardinality d.

x^3 + 2x +1 =0 

degree =3
cardinality = 4 {x,x,x,x (one x from 2x),} or {x,x,x,x,x}

problem x ^3 + 2x^1 +1  =0 
solutions of a polynomial equation of degree d always form a multiset of cardinality d. 
	
	expoenent equal = mulitplicty
	proble x^4 + x^3 +1 = 0
	
	
	Solution degree = 4 , 
	
Fundamental theorem of algebra thnik is wrong

	n=3, posicieos = 3
	
	3^3 possible combs
	
	(1,2,3)(3,2,1)(2,1,3)(2,3,2)(3,2,1)(3,1,2) = 6 combs
	
	
	(1,1,2 (1,2,1) (2,1,1)					(1,1,3)(1,3,1)(3,1,1) = 
	
	
	 (1,1,x1)( 1,x1,1)(x1,1,1)(1,1,x2)(1,x2,1)(x2,1,1)
	 
	
	
	
	
	Arranjo simples de n elementos tomados r {\displaystyle r} r a r {\displaystyle r} r
	 
	(2,2,1)     (2,1,2)	(1,2,2)(2,2,3)(2,3,2)(3,2,2)
	
	pos1, pos2, pos 1 +pos3 , pos 
	
	(3,3,2)(2,3,3)(3,2,3)(3,3,1)(1,3,3)(3,1,3)
	(1,1,1)(2,2,2)(3,3,3)
	
	
	Arranjos com repetição = 


   	1,2,255,255} => {1,2,255}  + positions of 255

{255,255,x,x)}
{x,255,255,x}
{x,x,255,255}  
{x,255,x,255}

	
	
		
	
	x = {1,2}
	
a)     {1,x,x,x}	linha 2 , Pos2 = Pos2 todas as posições 2 são iguais 		 
 line2 [x,1,x,x)  	
       (x,x,1,x)  			   
       (x,x,x,1)			 	
      				
      					 	
      							(x,y) coordenadas da matriz
      							num linha X = posicao X
	a) linha 1 , pos 1			num linhas (1) = posicao(1,1)	
	a) linha 2 , pos 2			num linhas (4) = ultima posicao (4,4)  
	a) linha 3,  pos 3
	a) linha 4,  pos 4         posicao(1,1) = num linhas (neste caso 1)
							   posicao(1,2) = num linhas 1 , pos 2
   lin1 {2,x,x,x)   		
   lin2 (x,2,x,x)   		
   lin3 (x,x,2,x)			pos(1,2) = pos(1,1) + pos(1,1) = 1.4 + 1.4 = 2.8
   lin4 (x,x,x,2)			pos(1,2) = soma dos valores = 2
   
				    
				    
			Matriz =111
				    011	Matriz triangular superior
			b)	    001
   					
   					100		
   			a)		110	Matriz trianguklar inferior
   					111			
		Transpose of b) = 
		
		
		
		a) forward substituion
		
		
		B) = A)tranpose
		
		a) and b) are not diagonal matrices
		
		A igual a transposta de B
		Bt = A
		A = At
		é simetrica
		
		algoritmo de solução (forward solution) de x's a) (Lower triangle)
		{x1 ... ...} = 1
		{x1 + x2...} = 2
		{x1+x2+x3..] = 3
		
		
		
		Matriz A,
		AB=BA = In , então A é invertivel , sendo A Lower triangular matrix e B upper triangular matrix
		então factorizacao possivel,
		
		a)			b)						Pos1 = linha 1
		[1,0,0]	[0,0,1]						[1,0,0] [0,0,1] 
		[1,1,0] [1,0,0]   multiplcation ->  
		[1,1,1} (1,1,0]
		
		
		
	A)	A pos2 = B pos2, visto que são quadradas e 
	
	quais os elementos que usam a a) pos2 linha 1 = b)  inha 2 pos 2,  
		A pos2 = 0 
	
	 a)linha 1 pos2 b) linha 2, pos1 
	 a)linha 1 pos2 b) linha 2 pos 2   =a) linha1 b) linha2 ,pos mesma
	 a) linha 1 pos2 b) linha 2 pos 3  			
				
		(0,1 (0,0) (0,
		
		getting pos2 , 
		escolhi pos2 (a), linha 1), logo obtem-se linha 2
        escolhi pos1 (a) , linha1  ), linha 1		 
		combinar 1linha [1,0,0] 2linha [1,0,0]
				[
	 	pos2 linha 1 = linha 2 pos 1   +  pos2 linha 1 = 
		[ 
	
	row{1][1][1] * col[ = num
	    
	dot product
		
	a)	linha1,pos2,pos3 , linha 2 pos3,
	b)  linha 1 pos1,pos2,pos3 , linha 2 pos 2,3,linha 3 pos 3
		
		 a matrix decomposition or matrix factorization is a factorization of a matrix into a product of matrices
		
		
		a) * b) = c)
		
		a = bt
		at = b 
		
		visto ser invertivel
		he LU decomposition factorizes a matrix 
		into a lower triangular matrix L and an upper triangular matrix
		
		
		so we have lower, upper triangle (a), b)) 
		and want to find thte (origianl matrix)

		X = LowerTraingle*UpperTriangule
		X = a) * b)
		
		



		tranopse of a) = b)
		transpose of b) = a)
		
		inverse fof a) = b)
		
	y the LU decomposition algorithm, an invertible matrix
	 may be written as the product of a lower triangular matrix L and an upper triangular matrix U if
		
		
		so the bytes (byte1,byte2)
					 (byte1,byte1)
					 (byte2,byte2)
					 (byte2,byte1)
		byte2 = Transposta de (byte1) 
			
			


		if pos1 = 1, entao em todas as posicoes na msema coluna estão set
		no casa da pos2 entao todas as posicao es de pos2 estao set
   								
   							vector = posicao	
							
							
							
						que vector representa a posicção
						
						posicao(3,1) = 5
						x=3 , y=1   = 
 						
 						(3,1) (0,0) =  
 						
 						sqr(x^2 + y^2) = 5
						
						
						
							
								pos(1,2) = pos(1,1) + pos(1,1) = 2
									
									sqr(5) = sqr(2) + sqr(2) = 
																	
								posicao(1,1) = 1 (ou 2)
								posicao(1,1) + pos(1,1) = 1+1 = 2 = pos(2,2)
								(1,1) = 1
								(1+1,1) = (2,1) = 1
								
								 
								 
								 
								posicao(2,1) = posicao(1,1) + pos(1,1) = 1+1 = 2
								
								Para ser dois na posicao(2,1) entao
										posicao(2,1) = 1 + 1 = 2
									
								
								pos(1,1) = 1
								
								posicao(3,1) = posicao(2,2) + pos(1,1) = (3,3)
								posicao(4,1) = posicao(3,3) + pos(1,1) =(4,4)
								
								Para pos(1,1) = 1 entao
								
								pos(2,1) = 1 ou 2
								
								se estao na mesma linha, entao qual o valor?
								
								pos1,pos2,pos3,pos4 (X,y=1)
								
								
								
								
								visto que estao na mesma linha, nao se pode adicionar
								
								pos(2,1) = 1+1  
								Para pos(1,1) = 2 entao
								pos(2,1) = 2+2
								
								pos(2,1) = pos(1,1) + pos(1,1)
								pos(2,1) = 1 +1
								 		 =  2 
								
								 
								pos(
								
								pos1 pos2 pos3
					pos1		(1,2,3)
					pos2		(4,5,6)
							
					posicao(1,1) = 1
					posicao(1,1) + pos(1,1) = 2 = pos(2,1)			 
								
								
								
								
								x=horizontal 	
								
								
								
											   posicao(2,2) =posicao(1,2)   
								
								(0,1) = linha 2? 
	
	b) linha 1 , pos1
	b) linha 2, pos2
	
      					 	
      					 	x  = pos2 a) pos2 b)
      					 	x1 = pos3 a) pos3 b)  	
							same line
							
						[1,1,1]
						[0,1,1]
						[0,0,1]
						[0,0,0]
						
						[0,0,0]
						[1,0,0]
						[1,1,0]
						[1,1,1]
						
						matriz A = At (transpose) , equal to triangular matrices 	
							 
							  
b)
[b,0,0,0}		USED	diagonal matrix
        	[0,b,0,0]	 3 bits -> zero em primeiro 
        	[0,0,b,0]	 2 bits
        	[0,0,0,b]    1bits
        		 
        		
				3combs
			[0,0,b,b]	2 bits
			[0,b,0,b}   3bits
			{b,0,0,b]   USED
			[0,b,b,0]    3 bits
			{b,0,b,0]	USED
			[b,b,0,0] 	USED
			
				3combs
			(0,b,b,b)	3bits
			(b,b,b,0)  USED
			(b,0,b,b)  USED
			(b,b,0,b) USED

				 a matrix decomposition or matrix factorization is a factorization of a matrix into a product of matrices
	 		  
	 		  
	 		  
	 