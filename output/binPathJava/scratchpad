A  1
B  2
C  3
D  4
E  5
F  6

Cada conjunto de bits, tem o numero de elementos do anterior * 2 , bitshift left

2 bits DIVISION	
	1   0
0	(0,1 (0,0)	
1   (1,1) (1,0)

		=> (01,11,10,00)				


3 bits DIVIISON
    000 
	001
	010 => 2 bits
	011

	111
	110 => 3 bits
	101
	011

4 bits DIVISION
	0000 
	0001
	0010 => 2 bits
	0011

	0111
	0110 => 3 bits
	0101
	0011

	1000
	1001
	1010
	1011 => 4 bits
	1100
	1101
	1110
	1111


De set E opara set C = (2,3) 2d comeca por um , 3d comeca por um 
De set C para Set D  = (4,5,6,7) todos os numeros cujo os bits são um
					   (8,9,10,11,12,13,14,15)
					   (16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31)

 

 

			
2	 	    4             8				 16			32
Set B     Set C  	    Set D   		Set E  		Set F
0         (0,0) 0  		(0,0,0) 0    (0,0,0,0) 0  (0,0,0,0,0)
1         (0,1) 1       (0,0,1) 1	 (0,0,0,1) 1  (0,0,0,0,1)
          (1,0) 2    	(0,1,0) 2    (0,0,1,0) 2  (0,0,0,1,0) => Set D (3bits)
          (1,1) 3    	(0,1,1) 3    (0,0,1,1) 3  (0,0,0,1,1)
          							 
          				(1,0,0) 4	 (0,1,0,0) 4   (0,0,1,0,0)
          				(1,0,1) 5    (0,1,0,1) 5   (0,0,1,0,1) => Set D (3bits)
          				(1,1,0) 6    (0,1,1,0) 6   (0,0,1,1,0) 
          				(1,1,1) 7    (0,1,1,1) 7   (0,0,1,1,1)
          				
          							 (1,0,0,0) 8   (0,1,0,0,0)
          							 (1,0,0,1) 9   (0,1,0,0,1) => Set E (4bits) plus leading 0,which equals 4bits
          							 (1,0,1,0) 10  (0,1,0,1,0)
          							 (1,0,1,1) 11  (0,1,0,1,1)
          							 
          							 (1,1,0,0) 12 (0,1,1,0,0)
          							 (1,1,0,1) 13 (0,1,1,0,1) => Set E (4bits) plus leading 0,which equals 4bits
          							 (1,1,1,0) 14 (0,1,1,1,0)
          							 (1,1,1,1) 15 (0,1,1,1,1) 16combs of leading zeros
          							 
          							 			  (1,0,0,0,0) => 5bits.just change one at the beggiging
          			
          		
          			
          		
				

2d		3d

To convert a 2 point to a 3d point just add it zero to the beggining
 
 
 
 2D =  3D
 
 3D - 2D => X=1
  
Trocaa 1 bit por 0 (ou revert SET D) 

col 1-2  = 2bits ( (1,0) (1,1) (1,0) (1,1) }
col 2-3  = 2bits ( (0,0) (1,0) (0,1) (1,1) )
col 1-3  =       ( (1,0) (1,0) (1,1) (1,1 ) 
colummns work....

row 1-2 = ( (1,0,0) (1,1,0) ) = Add one element to the last position
row 2-3 = ( (1,1,0), (1,0,1))
row 3-4 = ( (1,0,1) (1,1,1 )
	
	Matrix T
	(1,0)
	(1,1)
	(1,0)	- 
	(1,1)

row 1-2 = ( (1,0) ,(1,1))
row 2-3 = ( (1,1) ,(1,0))
row 3-4 = ( (1,0) (1,1)


Se tiver 2 colunas,columns on table? coluna 1 , coluna = 0


coluna 2  = 1bit table + ( (0,0) (1,0) )
 
	1      0		0
0	(0,1 (0,0)	
1   (1,1) (1,0)

coluna 1 bit = (01,11)

coluna 1
 	1
 0 01
 1 11

	
	
compare 1 ,2 ,3  => K values, são os valores adicionados no inicio de cada combinação de bits
quando k=3, elimina k=2?

(1,0,0,0) (2,0,0,0)(3,0,0,0)
(1,1,0,0, (2,0,1,0)(3,0,0,1) 	

(1,1,1,0,0,1)
(1,1,0,1,0)

num de colunas = numero de bits

2 bits -> 2d
3 bits -> 3d

so columns are 2bits  , if a column added addes a bit to the rows from (0,1) to (0,0,1) col 3 added



Se o digito inicial for zero, então metade dos arranjos anteriores ja estao contabilizados

Se adicionarmos ultimas coordeandas , a um ponto que tenho X=0 então as coordenadas continuam as mesmas

cartesian prod 3bits = cartesian prod_2 + ( 
						cartesian_prod1 X cartesian_prod_2 ( (1,0) (1,1)
						
						cartesian product = obter produto cartesiano anterior (por exemplo producto carteseiano de 2 bits)
						* producto cartesiano 3 bits ( 
						
3 bits -> 2 bits mais uma coluna


Add bits to (0,1) for example (0,1,0) or (0,1,1) 
three bits
	1   0   1
0   X   X    
1   X   X  (1,0,1)

    

  Tress bits, faltam (4,5,6,7)
  00000100,00000101,00000110,00000111
  
  

							5bits = igual a 3 bits (cada posicao tem os seus zeros) + 2 zeros (zeros iniciais)
							5 bits = igual a 3 bits + 1zero
							
							0..8 = 3 bits    
							8...16 = 4 bits  (ignorar)
							16....24 = 	5bits						
							24...32 = 6 bits (ignorar)
							32....40 = 7 bits
									f(
									
									X Number of bits, N number
								
									f(N) = 8*i (16,24)
										
										[0,1,2,3,4,5,6,7]
										obter num de bits
						
					
													 
						calculate graphic (number of positions on the graph = number of bits)
						 
						 
						 +2 ou +3
						 
						  
						 					Para cada border, subtrai-se um zero
															 border of 3bits								border of 3 bits
			 Bits 		Pos1 Pos2 Pos3 Pos4 Pos5 Pos6 Pos7 Pos8 | Pos9 Pos10 Pos11 Pos12 Pos13 Pos14 Pos15 | Pos 16 Pos17 Pos18 Pos19
			 
			 3bits		3	   2   1	1	0    0    0     0											15d		
		(3bits +2 bits) 
			 5bits      5	   4   3    3	2	 2	  2	 	2	   1		1	1		1	1	 1		1
			(3bits +3)			
			7 bits 		7      6   5    5   4    4    4     4		3       3   3       3   3	 3		3      2     2       2       2							2	2		2	2
			
			
			
						i=0 	F(Pos) = 3(bits) + 2i
					    i=2
					    i=3		
					    
					    	PosX (5 bits) = PosX ( 3bits) + (5-3)
					    	PosX (7 bits ) =PosX (3its) + (7-3)
				
				7Bits
				0 -> 7zeros
				1 -> 6 zeros
				2-> 3 -> 5zeros
				4-> 7 -> 4 zeros (3bits)
				
				
				8   -> 16 => 3 zeros (5bits)    
				16 -> 32  = 2zero  (7bits)
				32 -> 64 = 1zero (9bits) ?
				64-> 128 = 
				
				
				
				De 8 a 16 é comutativo 
				
				
				
				Se for para contar uns, então POSX = VALOR(X);	    
					    	
					    
					    POSITION = valor(position)
								X= Position of 5bits = pos1+ = bits3+2
		7bits = 3bits + 4bits							
							0...8 = 3bits 
							16...24 = 5bits
							32...40 = 7bits
							
							
				00001 3bits + 2 							
			
							
							
			
							 
Para valores menores que (8,16 ,31 ,63) 
	
	
	0 <=  agrupamento_Q < 8 
	8 <=   agrupamento_w < 16  (comeca por 1 ignorar)
	16 <=  agrupamento_j < 24 
	24 <= agrupma.....< 32  (comeca por 1 ignorar)
	32 <= ar.....   < 40
	40<= .... < 48 comeca por 1 ignorar
	48 <= .... < 56
	56<= .... < 64 1 ignorar 
	64<=   ... < 72
	
	
	0,16,32,48,64
						num de bits estao relacionado ?
	quanto zeros 0 ? => 4+3+2+3+2+3+2+1 = 20 zeros 
	quantos zeros 16?
	


								
1000 8
1001 9
1010 10		-> AAGRUPAMENTO W
1011 11					  	
1100 (12
1010 13
1001 14
1111 15

obter numero de zeros a esquerda (4bits) , metade dos valores tem 0 no inicio
		if (firstBit == 0 )
		

 
		(b1,b2)
		(b1,b1)
		(b2,b2)
		(b2,b1)		
		numero total de mudanças de ordem
		4
		
		
		
		Se 3 belongs to i, and 2 belongs to i then both belong to i
		
		or 3 = 2 = i
		
		obter todas as combinações , do conjunto em que tenha 3 bits
		quais os limites?
		1 <= 3 <= 8 ?

		
		  				
	
1	1	1	1   1
AGRUPAMENTO A

	0	1   1	1 
	1	0	1	1  => one zero per linhe      Numeros binarios em decimal neste agrupamento (7,11,13,14)
	1	1	0	1
	1	1	1	0
	
AGRUPAMENTO B   TRANPOSTA DE A?
 
	0	0	1	1
	0	1	0	1
	1	0	0	1  
	1	1	0	0 => dois zeros per line  (3,5,9,12,6,10)
	0	1   1   0    
	1	0	1	0
	
AGRUPAMENTO C
	0	0	0   1 		
	0	0	1	0 => tres zeros per line (1,2,4,8)
	0	1	0	0
	1	0	0	0
		 
	0	0	0	0
-----------------------		
	Ao adicionar um , apenas de adiciona um. Se se adicionar um zero, se o anterior ou o posterior for zero, nada se aumenta nada
	
	Para cada agrupamento , o NUMERO de uns e zeros é igual em cada linha. 	
	
	Agrupar 4bits, por numero de zeros (ou por uns). assim contar as combinações de uns (java igual zeros as variaveis por default)  
	
	4 * 1zero (7,11,13,14)			Number of zeros no agrupamento A = 4 zeros
	6 * 2zeros (3,5,9,12,6,10)		numero de zeros no agrupamento B = 12 zeros
	4 * 3zeros (1,2,4,8)			Numero de zeros no agrupamento C = 12 zeros
	
	4 bits começando por zero (0111, 0101,0110,0011,0001,0010,0100,0000) são iguais a 3 bits, então para obtermos todos os 4 bits,
	basta adicionar 1 no inicio		
				



relationsship between 4 bits and 3 bits
	
	 
				relationship betwen first bit and second bit 
			trying only with ones (use cycle to iterate index and assign ones
			zeros are already taken by java
			
			first bit
			2,4,6,8		10,12,15,16
			
		
			
				// Set first bit to 1
				// set second bit to 1
				// set third bit to 1
			
				
			3,4,7,8,	11,12,15,16
		
			third bit
			5,6,7,8,	13,14,15,16		
	  	 
			 
			 
			  
			  
			*/
		
	
		
		
		// skip counting zeros, just assign arrays to 1..the others are 0
	/*	
		
		n) = m) + 1111 + m)		
			
			 0000 0111 + 0000 1111  + 0000 0111
		
	set 2    set 1	
	m)	0000 0111	7		
		0000 0011	3
		0000 0101   5
		0000 0001	1		 (1,2,3,4,5,6,7,8)
		0000 0110	6		+1111 +1111 +1111  	
		0000 0010	2			
		0000 0100	4
		0000 1000  8
		
		 
		112   7				119-112 = 7d 
	n)	0111 0111 119 		we subtract the number 
							from the 1set of binaries to
							the number (119d-0111b (7d) on 7 on m)
							and another example 51d-011 on 3 on  m) 
		0011 0011 51
		0101 0101 85
		0001 0001 17
		0110 0110 102
		0010 0010 34 
		0100 0100 68 
		0000 1000 8						
		
o)		0111 0000 112					set 1 = tem de ser igual a (1,2,3,4,5,6,7,8)  ou tudo a zeros?
										set 2=   (1,2,3,45,5,6,7,8) ou zeros ?
		0011 0000 48
		
		0101 0000 80
		0001 0000 16					1 = (1,2,3,4,5,6,7) 	?						0  = zeros??
		0110 0000 96					
		0010 0000 32					(1,1) (0,1) (1,0) (0 , 0) => Todas as ordens possiveis
		0100 0000 64				
		1000 0000 128						
		
		
												0,17,34,51,68,85,102,119
		o) = m) + 1111
		n) = o) + m)
								minus -     0  1  2  3  4  5  6  7  m)  ( 0, 1)
	
	
    
    
											    0,16,32,48,64,80,96,112 o) (1,0)
		
								divide_by_16 
								
												0,1,2,3,4,5,6,7					
			
				shift esquerdo = dividir por 16
				k= h)#1 / g)#1 = 16  
				k= h)#2 / g)#2 =  16
				k= h)#3 / g)#3  =  16
				
					f(g) = h)#1 / k , com k= 16
							
					i#1-g#1 = h#1
				
					f(g) = (i#1-g#1) / k
								

				
				a constante é 16 neste caso (para outros bits serao o mesmo)
				
				
				
								
g)  0000 1000	8d							
	0000 1001   9d
	0000 1010   10d
	0000 1011   11d
	0000 1100	12d
	0000 1101   13d
	0000 1110   14
	0000 1111   15
	0000 1111  16
	
	
	
h)							128 = 8*16   ( 8d * )
	1000 0000  8k = 128 , k=  128 / 8 => 16d = 8d
	1001 0000  144 = 9K = k= 144/9 => 16					
	1010 0000	160 = 10k = 16	 										
	1011 0000
	1100 0000
	1101 0000
	1110 0000
	1111 0000
	
	 
	
i)
	1000 1000  		i#1 = g#1+h#1 
	1001 1001  		i#2 = g#2+h#2   
	1010 1010  		 	
	1011 1011
	1100 1100
	1101 1101
	1110 1110
	1111 1111
	
												
					
		linha=8 bytes
		col = 2
												
												
					(1,1,1)(1,1,0)(1,0,1)(0,1,1)(0,0,1)(0,1,0)(0,1,0)(000)		
													
						0 = zeros?	1= (1,2,3,4,5,6,7) or 1 = (1,2,3)			
												

		bits iniciais 4 , maximum => 2 positions
		bits iniciais 8 , maximum => (2^3) 3 posicoes 		
		bits iniciais 16 , maximum => (2^4) 4 positions
		bit  iniciais 32 , maximum -> 5 positions 
		bits iniciais 256 , maximum => 8 positions 
		bits iniciais 512 -> maximum => 9 positions 
		bytes iniciais 4294967296 -> 32 positions?
				
				ou seja vai diminuindo pela posicioes.....(menos 2vezes)
		
   4    3   2   1 				
b)	1	1	1	1 
	0	1   1	1 
	1	0	1	1  
	0	0	1	1  
	1	1	0	1    
	0	1	0	1		4 coluna = 3 coluna de a)   
7	1	0	0	1		3 coluna = 2 coluna de a)
	0	0	0   1 		2 coluna = 1 coluna de a)
	1	1	1	0		 
	0	1   1   0    
	1	0	1	0
	0	0	1	0
	1	1	0	0		
	0	1	0	0
15	1	0	0	0		 
	0	0	0	0
		
	
	(4,3,2) ->  2threebits
	(1,2,3) -> nada
	 
	8 bits-> 32
	9 bits-> 64
	10 bits ->128
	11 bits -> 256
	12 bits -> 512
	13 bits -> 1024
	14 bits -> 2048
    15 bits -> 4096										
	16 bits -> (anterior ) * 2  
			-> 8192 * (1.....8192 of three bits)
					
					7 * 8192
					57344
					
		3bits ->8 combinações
		
		threeBits(7) = #8
		threeBits(15) = #8
	
	
	poupar 3 bits pois ao sempre igaugis em todas as posicoes
	
		threeBits = 16 elemets
	3 bits -> 1 * threeBits(7); => 8
	
	4 bits -> threeBits (7,15)  => 2*8 // 2*8
	
	5 bits -> threeBits (7,15,23,31) // 4*8
	
	6 bits -> threeBits (7,15,23,31,39,47,55,63) //8 * 8 

	
	//-- three marker bits
	
	5 bits- > (4bits,23,31)
	6 bits-> (5bits,39,47,55,63)
	7 bits-> (6bits,71,79,87,95,103,111,119,127)
	
	256 bits have 3 bits initials 
	
	/*Percorrer o mesmo ciclo e adicioainar 7
	
	15    = 0b1111
	23    = 0b10111 (15+7)
	31    = 0b11111 (23+7)
	
	byte1
	0b0 0 0		
	0b0 0 1			
	0b0 1 0		
	0b0 1 1		
	0b1 0 0		
	0b1 0 1		
	0b1 1 0		
	0b1 1 1		
				
					
	byte2
	0b0 0 0
	0b0 0 1
	0b0 1 0
	0b0 1 1
	0b1 0 0
	0b1 0 1
	0b1 1 0
	0b1 1 1 	 
	
	since they are equal to the first byte, one can assign without cycle
	
	3bits , All combinations = 2^3 = 8 bits
	4bits , All combinations = 2^4 = 16bits
	5bits , All combinations = 2^5 = 4 bytes
	6bits , All combinations = 2^6 = 8 bytes
	7bits , All combinations = 2^7 = 128combs
	8bits , All combinations = 2^8 =  256 combs
	256bits , All combinations = 2^256
	
	1)00 10 01 11 2^8 = 256 combs 2) 11 01 10 01 = 256comb 2^8
	 
		se 2^8 entao todas as combinações no primeiro byte
		de 1) são iguais ao 2)
			
			
			 o prmeiro byte vai ser semptre [1...256]
			 o segundo byte vai ser sempre [1..256]
	 para 2 bytes
	 primeiroByte[1...256]	primeirobyte[1...256]
	 segundo byte[1...256] primeirobytye[1...256]
	 segundobyte[1...256] segundobyte[1...256]
	primeriobytye[1..256] segundo[1...256]
	
	n=2 , p =2
	
	{p,s} => {ps,sp,ss,pp}
	 
	n={1,2,3,4}
	p= {4}
	
	it a = 2^8
	arr[a][a] = [1..256][1..256][1..256]
	aplus = 2^8*2
	
	arr[1plus[
	1 -> index da array
	Para 1 byte
	[1....256]
	Para 2 bytes 
	2->index da array = position 2
	[1...256] [1...256] // concat
	1) = anterior
	2) = anterior
	3) = anterior
	
	
	
		
		
	
	int sizeByte[] = {  0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 , 11 , 12 , 13 , 14 , 15 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 , 25 , 26 , 27 , 28 , 29 , 30 , 31 , 32 , 33 , 34 , 35 , 36 , 37 , 38 , 39 , 40 , 41 , 42 , 43 , 44 , 45 , 46 , 47 , 48 , 49 , 50 , 51 , 52 , 53 , 54 , 55 , 56 , 57 , 58 , 59 , 60 , 61 , 62 , 63 , 64 , 65 , 66 , 67 , 68 , 69 , 70 , 71 , 72 , 73 , 74 , 75 , 76 , 77 , 78 , 79 , 80 , 81 , 82 , 83 , 84 , 85 , 86 , 87 , 88 , 89 , 90 , 91 , 92 , 93 , 94 , 95 , 96 , 97 , 98 , 99 , 100 , 101 , 102 , 103 , 104 , 105 , 106 , 107 , 108 , 109 , 110 , 111 , 112 , 113 , 114 , 115 , 116 , 117 , 118 , 119 , 120 , 121 , 122 , 123 , 124 , 125 , 126 , 127 , 128 , 129 , 130 , 131 , 132 , 133 , 134 , 135 , 136 , 137 , 138 , 139 , 140 , 141 , 142 , 143 , 144 , 145 , 146 , 147 , 148 , 149 , 150 , 151 , 152 , 153 , 154 , 155 , 156 , 157 , 158 , 159 , 160 , 161 , 162 , 163 , 164 , 165 , 166 , 167 , 168 , 169 , 170 , 171 , 172 , 173 , 174 , 175 , 176 , 177 , 178 , 179 , 180 , 181 , 182 , 183 , 184 , 185 , 186 , 187 , 188 , 189 , 190 , 191 , 192 , 193 , 194 , 195 , 196 , 197 , 198 , 199 , 200 , 201 , 202 , 203 , 204 , 205 , 206 , 207 , 208 , 209 , 210 , 211 , 212 , 213 , 214 , 215 , 216 , 217 , 218 , 219 , 220 , 221 , 222 , 223 , 224 , 225 , 226 , 227 , 228 , 229 , 230 , 231 , 232 , 233 , 234 , 235 , 236 , 237 , 238 , 239 , 240 , 241 , 242 , 243 , 244 , 245 , 246 , 247 , 248 , 249 , 250 , 251 , 252 , 253 , 254 , 255 }; 
	

     
	
	
	
	
	 
				
	
		
		
	
	
	
	
	


		
		/*
		 * 
		 * g,h,i
		 * 
		 */
		
		
		
	
		// ones and ones after 3 bits
		
		// 4bits-> so three bits use 
		// 4 Bits  (2threebtes markers) 8 ones 8 zeros
		// 4 bits below
		
		
	/*base three bits- > 8 , add  10000 (8) to three bits
	base three bits -> 8 , add  11000 (16)  
	base_three_Bits -> 8,  add  11100 (24)
	
		   first 5 bits , needs to be added to bthree bits
	
			add number to three bits, constante? 
			
					
			00000 000
			00000 001
			00000 010
			00000 100
			00000 111
			00000 101
			00000 011
			00000 110
			
			a      b		
			00001 000
			00001 001 c)
			00001 010
			00001 100  
			00001 111
			00001 101  PErcorreu 8 bbytes
			00001 110
			00001 011
			
			
			so marker (001) appears on 5 msb in [8..16 bytes]
			so marker2 (010) appears on 5 msb in [16...24]
			so marker3 (011) appears on 5 msb in [24..32]

					
					4 bits iniciais = 4 bits finais
					
			1		001  b  1   111 a1	 	1 	011	 i 3
			2		010	 c	2	001 a2		2	    101	 j 5
			3		100	 d	4	101 a3     	3	110  k 6
			4		111	 e	7	110 a4		4	111	 l 7
			5		110	 f	6	011 a5		5	100	 m 4
			6		101	 g	5	010 a6		6	010	 n 2
			7		011	 h  3   100 a7 		7	001	 o 1
			
		
					
1		010 2 p		 				
2		111 7 q		 
3		001 1 r  	 
4		100 4 s     
5		110 6 t
6		101 5 w
7		011 3 x
						b=001
						
relação entre valor e posição
			Pos1 () => 001,111,011,010,101
			
			Pos2 =>   010,001,101,111
				
			pos1[0] = pos2[0] ?
			
			
			
			Se tiver desordnado (ou seja nao sequencialmente (3,4,1) (snaõ as posicoes sao iguais)
			
			Pos 1 = 2,5,3,6,7
			Pos 2 = 3,2,5,7,6							Quero permutar Pos1 
			
			For Pos1(2) ={3,2,5,7,6}	// Pos1(1idx) = everything from Pos2 
			For Pos1(5) = {3,2,5,7,6}  // Pos1(2idx) = Everything from Pos 2
			
			
			
			
			For pos1(2) = {2,3,5,6,7} 
			from unorder to order...
			For Pos2(2) = {2,5,3,6,7}
			
			
			indices are 1,2,3,4,5
			            2 3 1 5 4
			            
			            		having 2 -> 1 , having 3->1 , having 1 -> 3,
			            			P1(1idx) => 1-> 2, => P2(1idx) = 2 
			            			P1(2idx) => 2 -> 3 => P2(2idx) =1 
			          
			            1,2,3,4,5
			            
			            1,3,2,4,5		1->1 ; 2-> 3 ; 3-> 2 ; 4->4 ; 5->5 (se num iguais-> num iguais nao fazer nada)
			      		
			          					 
			           
			           1,3,4,2,5
			           
			           1,5,4,2,3
			           
			           
			           
			           
			            		
			            so we equal indices on Pos1 and get the value of Pos2 on that index
			
		sequence(5idx) 
			
			P1(1idx) => P2(2idx) --> 1idx->2idx
					
			P1(2idx) => P2(3idx) 2idx-> 3idx
			
			
			P1(3idx) => P2(1idx) 3idx -> 1idx
			
			troca de indexes.
			
			P1(4idx) => P2(5idx) 4idx -> 5idx
			
			P1(5idx) => P2(idx4) 5 -> 4
			
			
			
			}
			
			Pos1[0] (001)  => Pos2[0]   (001)
			
			se pos1[0] (111) => Pos2[4]  (111)
			
			
			
			
			Pos1(111) => Pos2(X)
			
			
			dont cycle every value (some are repeated (010,111,001))
			
						I can just assign one pos, the other are equal
					 b 		  o			r	
					Pos 1 -> Pos 7 -> Pos 3 (same bits)
						
					
					c  		  n 		p
					Pos 2 -> Pos6 -> Pos 1 
					010		 010 		010
					
					Pos 2 = { 010,101,111}
							 Pos2 Pos6 Pos 1
							
				    pos[0] = b ; pos[0] = o ; pos[0] =r;
					 Pos 1		=		Pos 7	= 	Pos 3
	
							 
					byte[] arr2 = new byte[8];
					byte[] arr3 = new byte[8];
					byte[] arr4 = new byte[8];
					byte[] arr5 = new byte[8];
					byte[] arr6 = new byte[8];
					byte[] arr7 = new byte[8];
					// iniciais, usados para atribuir valor
					
					
					for (int i= 0 ; i < 8; i++) {
						pos[i] =  0b000;
						arr7[i] = 0b001;
						arr2[i] = 0b010
						arr3[i] = 0b011;
						arr4[i] = 0b100;
						arr5[i] = 0b101;
						arr6[i] = 0b111;
						
						
						
						// Todas as possiveis lugares de 001 (i lugares)
 
						
					}
								
								
					
					
						
						
					
					P = {a,b,c,d};
					n=4
					p=2arr[2* 

					4A2 -> n^p
					
				Ou seja os numeros acontecem em posicoes diferentes
				com o mesmo valor (só possivel se houver permutação de elementos)
								
		b=o 
		
		d=m					P1 = {a,b,c,d,e,f,g,h}
		e=l					P2 = {i,j,k,l,n,n,o,p}
		f = k				nP1 = 8
		g = j				nP2 = 8
							p= 3
		h = i			
					Pos b = Pos o?
				Arrrajos = {b,c,a},{d,e,f}
			
							{o,n,p} {m,l,k
		ordem diferente mesmos numeros
					
		Arranjos 
		ou seja ao adiconar um zero anterior ao numero, = 8C8
		
			5 bits
			 00000 000 (0)				1
			 00000 001 (1)	*marker
			 00000 010 (2)	*marker 2 
			 00000 011 (3)	*marker 3
			 00000 100 (4)	
			 00000 101 (5)	
			 00000 110 (6)	
			 00000 111 (7)	  	8
			 00001 000 (8)	
			 00001 001 (9)	
			 00001 010 (10)	
			 00001 011 (11)	
			 00001 100 (12)	
			 00001 101 (13)	
			 00001 110 (14)	
			 00001 111 (15)	
			 00010 000 (16)				16
			 00010 001 (17)	
			 00010 010 (18)	
			 00010 011 (19)	
			 00010 100 (20)	
			 00010 101 (21)	
			 00010 110 (22)	
			 00010 111 (23)	  
			 00011 000 (24)			24
			 00011 001 (25)	
			 00011 010 (26)	
			 00011 011 (27)	
			 00011 100 (28)	
			 00011 101 (29)	
			 00011 110 (30)	
			 00011 111 (31)	   32 
			
			
			
			 } 

			
			*/
		
		
		
        	
        	 
	1 = 01
	2= 10
	3= 11
	 posicao (1,2,3) pos1
	 		  01 10 11 	
	 		  
	 		  
	 		  
	 posicao (3,1,2) pos2
	 		 11 1 10
	 posicao (3,2,1) pos3
	 
	 posicao (1,2,3,4)
	 		
	 
	 
	x^3 + 2x +1 = 0 (eq. polinomial)  {x,1} x cardinality 4 {x,x,x,x,x,1} cardianlyu 6, degree =6 ? 
	
	x*x*x 
	
	Para x=2 2^3
	cardinalyt = sum of X and numbers

cardinality = size of multipset

asserts that the complex solutions of a polynomial equation of degree d always form a multiset of cardinality d.

x^3 + 2x +1 =0 

degree =3
cardinality = 4 {x,x,x,x (one x from 2x),} or {x,x,x,x,x}

problem x ^3 + 2x^1 +1  =0 
solutions of a polynomial equation of degree d always form a multiset of cardinality d. 
	
	expoenent equal = mulitplicty
	proble x^4 + x^3 +1 = 0
	
	
	Solution degree = 4 , 
	
Fundamental theorem of algebra

   	{1,2,255,255} => {1,2,255}  + positions of 255

{255,255,x,x)}
{x,255,255,x}
{x,x,255,255}  
{x,255,x,255}


	
	
		
	
	
	

							    
							    
							    
			Matriz =111
					  111
				  3d  011	Matriz triangular superior
			B	  1d  001
   					
   				  4d  100		
   			A	  6d  110	Matriz trianguklar inferior   Btranposta = A
   				  7d  111			
		
		faltam 2,5
				  000
				  010 2d
				  101 5d	
				  
				  1Symmetric matrix is a square matrix which is equal to its transpose
			
				   
				    				  
	MATRIX A	  row1 11111111  255
				  row2 11111110  254 
				  row3 11111100  252
			MSB	  row4 11111000  248
				  row5 11110000 240			MATRIX A INVERTIBLE	
				  row6 11100000 224			A triangular matrix is invertible if its diagonal entries are non-zero
				  row7 11000000 192			3. A triangular matrix is invertible if and only if all diagonal entries are nonzero.
				  row8 100000000 128		
				  
  MATRIX B		  row 1 = 00000000 0
				  row 2 = 00000001 1			MATRIX A E B ARE _UNITRIANGULAR
				  row 3 = 00000011 3			MATRIX A REVERSE OF MATRIX B
						  00000111 7		    MATRIX Atransposed = B
		LSB				  00001111 15			MATRIX Btranposed = A
						  00011111 31			transposed it the reverse for row 1 col1 (on matrix a) = reverse value on matrix b
						  00111111 63
						  01111111 254			MATRIX B NOT NIVERTIBLE
						  
				  
				    00000001 	1
  MATRIX C  		00000010	2			MATRIX C invertible
				    00000100	4		
				    00001000	8
				    00010000	16
				    00100000	32
				    01000000	64
				    10000000	128			matrix C) simetrica (c= ctransosta)  
				    						MATRIX C não é transposta de MATRIX D
				    
MATIX D
					1111110  254
					1111101  125			matrix D) simetrica (D = Dtransposta), não transposta de MATRIX C
					1111011	 123
					1110111	 119 
					1101111  111
					1011111 not used
					0111111127
solutions)				  
				  Assign zeros from MATRIX C to MATRIX AND B
				  
				  00100110 AND with C) (2,4,32) => row 2,row3,row 6 
				  		  
					REVERSE MATRIX C TO GET ZEROS ON A AND B 
		
					
					j = row 
					i = col		
		row=1 col=1  => row3 col1
		row=1 col=2  
		row=1 col=3 1
		row=2 col=1 0
		row=2 col 2 1
		row=2 col 3 0
		row=3 col 1 1
		row 3 col2  0
		row 3 col3  1
		 
		
		
		A and B are not diagonal matrices (diagonal must be 0)
		
		A igual a transposta de B
		Bt = A
		A = At
		é simetrica
		
		an A  matrix é simetrica  se A=Atrans o que significa aij=aji
		
		E = [1 0 0 ]   F = [1 1 1]  E F  = [ 1 1 1 ]			
		    [1 1 0 ]       [0 1 1]         [ 1 2 2 ]
		    [1 1 1 ]       [0 0 1]         [ 1 2 3 ]
		
	F E =  [ 3 2 1]
		   [ 2 2 1]			EF  is symetric = EF = (EF)T 
		   [ 1 1 1]         FE  = symetric = (FE)T = FE
		   					E not symetric
		   					F not symetric
		   					EF+FE 
		   					
		   [3 2 1]	[1 1 1]				[ d  a12  a22 ]
		   [2 2 1] +[1 2 2] =>  		[a12 d1   a21 ]    
		   [1 1 1]	[1 2 3 				[a22 a21  d2  ]
		   
		   d = 3+1
		   d1 = 2+2
		   d2 = 4
		   
		   a12 = 3					
		   a22=1+1 					
		   a21= 1+2					
		   
		   Sum = equals multiplication
		   
		   2x = x+x
		   
		  
		   
		   
		   				   	
		 The sum and difference of two symmetric matrices is again symmetric
		 
		 
		  		(A + B)T = AT + BT:    
				(1,2) = ( (1,2) + (		  		
		  		   
		  		    
		  		                            
		The product of two triangular matrices is triangular
		A triangular matrix is invertible if its diagonal entries are non-zero
		
		
		
		Matriz A,
		AB=BA = In , então A é invertivel , sendo A Lower triangular matrix e B upper triangular matrix
		então factorizacao possivel,
		
		a)			b)						Pos1 = linha 1
		[1,0,0]	[0,0,1]		
		[1,1,0] [1,0,0]   					
		[1,1,1} (1,1,0]						
		
		
		if element of matrix is zero, no need to calculate multiplication
		
		
									
											
		Lower triangle = {1, 0 0]	Lower e upper  								
						  0  1 0 
						  0  0 1
		 						
	A)	A pos2 = B pos2, visto que são quadradas e 
	
	quais os elementos que usam a a) pos2 linha 1 = b)  inha 2 pos 2,  
		A pos2 = 0 
	
	 a)linha 1 pos2 b) linha 2, pos1 
	 a)linha 1 pos2 b) linha 2 pos 2   =a) linha1 b) linha2 ,pos mesma
	 a) linha 1 pos2 b) linha 2 pos 3  			
				
		(0,1 (0,0) (0,
		
		getting pos2 , 
		escolhi pos2 (a), linha 1), logo obtem-se linha 2
        escolhi pos1 (a) , linha1  ), linha 1		 
		combinar 1linha [1,0,0] 2linha [1,0,0]
				[
	 	pos2 linha 1 = linha 2 pos 1   +  pos2 linha 1 = 
		[ 
	
	row{1][1][1] * col[ = num
	    
	dot product
		
	a)	linha1,pos2,pos3 , linha 2 pos3,
	b)  linha 1 pos1,pos2,pos3 , linha 2 pos 2,3,linha 3 pos 3
		
		 a matrix decomposition or matrix factorization is a factorization of a matrix into a product of matrices
		
		
		a) * b) = c)
		
		a = bt
		at = b 
		
		visto ser invertivel
		he LU decomposition factorizes a matrix 
		into a lower triangular matrix L and an upper triangular matrix
		
		
		so we have lower, upper triangle (a), b)) 
		and want to find thte (origianl matrix)

		X = LowerTraingle*UpperTriangule
		X = a) * b)
		
		



		tranopse of a) = b)
		transpose of b) = a)
		
		inverse fof a) = b)
		
	y the LU decomposition algorithm, an invertible matrix
	 may be written as the product of a lower triangular matrix L and an upper triangular matrix U if
		
		A= byte1; B = byte2 ; C =byte3
		 (A,B,C)
MATRIX M (A,C,B)
		 (B,A,C)
		 (B,C,A)
		 (C,A,B)
		 (C,B,A)
		
			relacionar permutações com matriz ; matriz = 3P3
			{a,b,c} {a,c,b} {b,a,c} {b,c,a} {c,a,b} {c,b,a} 
		
		Properties of matrix M ? ,they will equal the 3P3 ..3P3 what properties
		
		
	A =[ 1 ....255]
	B =[ 1 ....255]
	C = [1.....255]
		
		
		
		 
			
			


							
							
							
							
						
						
						igualando a posicao a 5 (arbitrario) a (3,1, arbitrario), quere-se as coordenadas dos vectores
						posicao(3,1) = 5 (magnitude)
						x=3 y=1
						sqr(x^2 + y^2) = 5 (5 sendo magnitude, calcular as coordenadas dos vectors 
						
						
						
						
									
																	
								
								 
								 
								Change tuples by matrices 
								posicao(2,1) = posicao(1,1) + pos(1,1) = 1+1 = 2
								posicao(3,1) = posicao(2,2) + pos(1,1) = (3,3)
								posicao(4,1) = posicao(3,3) + pos(1,1) =(4,4)
								
							 	(1,1) = [1 1 ]
									pos (1,1) + pos(1,1) = [1 1] + [1 1] = [2 2]; 					
	 							(2,1) => [ 2 1 ]	
							 
(a+b) trans = atrans + btrans
							  
b)
			
			[b,0,0,0}		USED	diagonal matrix
        	[0,b,0,0]	 3 bits -> zero em primeiro 
        	[0,0,b,0]	 2 bits
        	[0,0,0,b]    1bits
        		 
        		
				3combs
			[0,0,b,b]	2 bits
			[0,b,0,b}   3bits
			{b,0,0,b]   USED
			[0,b,b,0]    3 bits
			{b,0,b,0]	USED
			[b,b,0,0] 	USED
			
				3combs
			(0,b,b,b)	3bits
			(b,b,b,0)  USED
			(b,0,b,b)  USED
			(b,b,0,b) USED

				  
				    00000001 	1
  MATRIX C  		00000010	2			MATRIX C invertible
				    00000100	4		
				    00001000	8
				    00010000	16
				    00100000	32
				    01000000	64
				    10000000	128			matrix C) simetrica (c= ctransosta)  
				    						MATRIX C não é transposta de MATRIX D

tem quantos pontos quanto linhas (linha 1 = point 1 )
tenho que seeparar em 3 bits... logo  3 bits (1 bit X , 2 bit Y, 3 bit Z) são posiçoes em 3d 

Se colunas da matrix for igual = 2  então é 2d
Se colunas da matrix for igual a = 3 então é definida por pontos

Se matrix lines = 3 então definida por pontos 3d
Se matrix lines = 2 entao definidade por pontos 2d
Mesma coisa para cols

			MATRIX W
				Line Points
				[ 2 1 3] -> ponto A (2,1,3)											ROWS			COLUMNS
	 		    ] 4 1 0 ] -> ponto B (4,1,0)		Wtransposta =    [2 4  2 ] Ponto G -> (2,4,2)   Pont J -> (2,1,3)  	
    		    [2 3 5  ] = ponto C (2,3,5)			  	             [1 1  3 ] Ponto H -> (1,1,3)	Pont K -> (4,1,0)								  	 
 		 		    Column Ponints									 [3 0  5 ]  Pont I -> (3,0,5)	Point L -> (2,3,5)
	 		    Ponto d (2,4,2)  igual a linha1  de Wtrans 
	 		    Ponto e (1,1,3),
	 		     Point f (3,0,5)
					
				
				Point A = Point J 
				Point B = Point K
				Point C = Point L  
				Point D = Point G
				
			Para W ser simetrica,   PONTO A (2,1,3) = PONTO G (2,4,2) 
									PONTO B (4 1 0) = PONTO H (1,1,3)
									PONTO C = (2,3,5) = Point I	(2,3,5)
									
									
									
									
									FACTORIZAO DE MATRIZES 
									TEM-SE UMA MATRIZ, E O PRODUTO ,FALTA SABER  A SEGUNDA MATRIZ NESTE CASO T
									
									a · (b · c) = (a · b) · c.
									
									MATRIX W		T	MATRIX WTransposta 
									[ 2  1 3]	[1 4 2/3] =	[ 2 4 2]	
									[ 4  1 0] * [1/4 1 0] 	[ 1 1 3]  
									{2   3 5]	[1 1 1  ]	[3 0 5]
									
									MATRIX W   MATRIX WTrans
									[2 1 3] * [2 4 2]	 [
									[4 1 0]	  [1 1 3] =>  
									[2 3 5]   [3 0 5] 
																		
									MATRIZ W  * T = MATRIX WTrans
									
									TRANSITIVY property?
									
									A = W
									B = T
									C = WTrans
									
									A*B = C 
									C * A = B?
									
									what if scalar is 1  ..that means identity ?
									
									reverse
									AB = BA = I
									
									A matrix can only have at most one inverse
									A(B+C) = AB + AC
									k(AB) = (kA)B = A(kB)
									(AB)C = A(BC) 
									
									A*B relates to B*C => A RELATES TO C transitivity
									 
									
								    
									 
									
								 	
																		
									
									
									
									Factor W * Factor T  = WTransp
										
										m that may be multiplied by some integer to produce n 
										MK=N 
										M factor, K integer,N multiple
										
										or several factors m1*m2*m3 = n ?
										
										
										
										
									[2 1 3] * [1 4 2/3]	 
									{4 1 0]   [1/1 1 0]
									[2 3 5]    [1 1 1 ]
									
									[ 2x 1y 3z] = [2 4 2]			[1 4 2/3 ]
																	[1/4 1 0 ]
									x=1 y=4 z=2/3					[1   1 1 ]
									
									[4x 1y 0z] = [1 1 3 ]
									x=1/4, y=1 z=0
									
									[2x 3y 5z ] = [2 3 5]
									x=1 y=1 z=1
									
									Matrices lower or uppper triangle are equal to the partiition
									
									
									
									PARTIÇÂO NUMERO 2
									2C1	2C2  
									2 	 1
									3C1	3C2 3C3  
									3	 3 	1
									
									
									
-------------------
obter valores de posicao...decompor numero em binario, e usar a funcao f(pos) = 8*i + pos
		Supondo i = 2
		valor = 16 +pos

		dado valor qual a sua posicao, tres bits iniciais do valor para 8bits.
		

---------------------------------------------
							P = { 5, 1, 4, 2, 3 }:
Here, 5 goes to 1, 1 goes to 2 and so on (according to their indices position):
5 -> 1
1 -> 2
2 -> 4
4 -> 3
3 -> 5
Thus it can be represented as a single cycle: (5, 1, 2, 4, 3).		




