	
		/*
		 * 
		 * n -> num de elems 
		 * p.-> quantidade de elemetnos por
		 *  Arranjos => n! / (n-p)!grupo
		 *  n -> 2
		 *  
		 
		 	4C2
		 
		 */
		 
		 		// 256 bits / / 8bits =>  32bits
		 
		
		            	// Permutation = > factorial de elemeentos
				// n elementos => n! combinações permutate
				 // int combinations 4294967296
				 
				 // x |= 0b1; // set LSB bit
        
        // x |= 0b10; // set 2nd bit from LSB
        
      //o toggle a bit use:
      //x ^= (1 << y) | (1 << z); // toggle yth and zth bit
      
      // x |= (1 << y); // set the yth bit from the LSB
      
      /* For Permutation , 32 times 8 positions , and permute -> time 370528=> 
	 * 370,528 sec
	 *  6.175466667 minutes
	 * 

	 * 
	 * For Permutation1 , 32 times 8 positions, 
	 * Time elapsed 70902

 aes 128, 192 e 256 bits (chave)
   256 -> 32 bytes
   32/4 = 8 ints
      unsigned long // 8 bytes  +  18,446,744,073,709,551,615] 
     unsigned int 4294967296


associativety -> a + (b + c) = (a + b) + c, and a · (b · c) = (a · b) · c.
comutative = a+b = b+a
additive and multiplicative a + 0 = a and a · 1 = a.
additive inverses a + (−a) = 0.

multiplicative inverses a -1 = 1/a . a* a-1 = 1
----Arranjos
n -> num de elems 
p-> quantidade de elemetnos por grupo

4A2 => n=4 p=2 2^4 (arranjos com repetição )  n^p
{1,2,3} = arranjos simples (sem repetição) = 312, 321, 132, 123, 213, 231 = n! / (n-p)! n=3 p=3 
--------------

	 	
----------------------------------------------bit wise operations---

x |= 0b1; // set LSB bit
x |= 0b10; // set 2nd bit from LSB

--------------------------------------------to erase a bit use:

x &= ~0b1; // unset LSB bit (if set)
x &= ~0b10; // unset 2nd bit from LSB
--- -----------------------------------------to toggle a bit use:
x ^= 0b1;

-------------------------------------------To dynamically set at bit, use:

x |= (1 << y); // set the yth bit from the LSB


-------------------------------------------https://stackoverflow.com/questions/523724/c-c-check-if-one-bit-is-set-in-i-e-int-variable
Check if bit N (starting from 0) is set:

temp & (1 << N)


---------------------------------permutations
Permutation = > factorial de elemeentos

----- multiset, 
In multiset {a, a, a, b, b, b}, a and b both have multiplicity 3.
allows for writing the multiset {a, a, b} as ({a, b}, {(a, 2), (b, 1)})
like [1,1,1,2,3] [1,1,3,2,1]


associativety -> a + (b + c) = (a + b) + c, and a · (b · c) = (a · b) · c.
comutative = a+b = b+a
additive and multiplicative a + 0 = a and a · 1 = a.
additive inverses a + (−a) = 0.

dsitributive
									a* (b+c) = a*b + a*c
									

multiplicative inverses a -1 = 1/a . a* a-1 = 1

MAtrices (A,B are) simetrct 

A = A' = [1 2] 	
		 [2	3]
B = B' = [5 6 7] 	
		 [6	3 2]
		 {7	2 1]
		 
		 5 BIT DIVISION (only zeros)		
00 000 (3bits)+2 (5 zeros)
00 001 4 zeros 							
									
00 010	3 zeros

00 100 2 zeros

00 101 2zeros
 										
00 110 2 zeros Pos 6)

00 011 3zeros
  
00 111 2 zeros


01 000	8d
01 001 9d
01 010 10d
01 011	11d					
01 100 12d
01 101	13d					
01 110	14d		three bits marker			
		 
		 
		 1 byte  first bits must be = 255  2^8
on  2 bytes first bits must be = 65535 2^16
on  3 bytes first bits = 16777216 2^24
  32 bytes frist bits = 2^(32*8)

  
  o multiply by any value of 2 to the power of N (i.e. 2^N) shift the bits N times to the left.

0000 0001 = 1 

times 4 = (2^2 => N = 2) = 2 bit shift : 0000 0100 = 4

times 8 = (2^3 -> N = 3) = 3 bit shift : 0010 0000 = 32
  
  
  The number to be multiplied is the "multiplicand", and the number by which it is multiplied is the "multiplier
									Usually the multiplier is placed first and the multiplicand is placed second
									
									

 // 256 bits , em bytes são 32
	   // 32 bytes / 4 bytes (size of int) = 8 ints
	    //64 bits * 4  = 256 ..
	    // Function for getting chars
	    // f(pos) = 8k+pos
	      
	    // 8*32 = 256  (one byte, combinations)
	   // 8* 8192  = 65536 (two bytes,combinations)
	   // 8* 536870912  = 4294967296 (4bytes , combs)


	         									
									