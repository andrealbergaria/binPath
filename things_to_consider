 
 to scan all bits, for better speed, fix at least one bit
for example

for 256 bits, set the first bit (one or zero) making it to scan 128 (less the first bit , which we fixed, and can be 0 or 1)

for catersian product

{ (0,1) ,(0m1) , (0,1) }

since the alrotihm is fast, there is a way to speed up multiplicaton by 2 (shifting bits) (perhaps changing positions)

we could use permutation on bits..for xample permute( {0,0,1} {1,0,1}) this we get us all values

on  1 byte  first bits must be = 255  2^8
on  2 bytes first bits must be = 65535 2^16
on  3 bytes first bits = 16777216 2^24
  32 bytes frist bits = 2^(32*8)
  
   binPath also solves traveling salesman problem
   biPath also crack bitcoin private key
   
   what is the plaintext?
   
    The most straightforward way is to obtain a
     few corresponding plaintext and ciphertext pairs, 
     that is, a known-plaintext attack. Alternatively, 
     a ciphertext-only attack is possible by decrypting 
     ciphertext using each candidate key, and testing the
      result for similarity to plaintext language — for example,
       English encoded in ASCII.
       
    to arranje several sublists, just join them on one list, and go for there
    
    		instead of going to 256 ,start on 256 and go (divide)
       
       4 bits, se 4 bit é igual a 1 é maior ten que (1,2,3,4,5,6,7,8) caso contrario  
			 
			00101010
			
			6 bit iset > 2^5
			numero maior que 2^5
			
			
			
			