	1 ALGORITHM
	
	get a base tuple, permute it, than add each individual elemenet of the tuple to the perumuted tuples
	
			2 ALGORITHM
			
			
	Starting with one change , to the base
then two changes to the base (can i use two cahnges with one change previous statement?)
thte three...tetc until all is done

example

(1,2,3)
---- first change
(2,1,3)
(1,3,2)
----second change (use the first change as base)(
(2,3,1)
(3,1,2)

------third change (use second change as base)
(1,3,2)
---the algorithm seems oks

vt.add(new Triplet(1,2,3));
		All changes are from the base
		vt.add(new Triplet(2,1,3)); ==> from (1,2) -> (2,1)   // 1 CHANGE
		
		vt.add(new Triplet(1,3,2));	 => from (2,3) -> to (3,2) // 1 CHANGE
		
		vt.add(new Triplet(3,2,1)); => (3,1) -> (1,3) // 1 CHANGE
		
		nem preciso de usar o tantas changes (visto as primeiras changes tomam as combinações) (1 change + 1 change = 2 changes)
		
											1CHANGE				1 CHANGE 
		vt.add(new Triplet(3,1,2)); => 	from (1,2) -> (2,1) && (2,3) -> (3,2);
										    1 CHANGE 			1 CHANGE		
		vt.add(new Triplet(2,3,1)); => from (3,2) -> (2,3) && (2,1) -> (1,2)
		
		 
	Ou seja preicso de 4 mudanças para obter tuplo (visto que , por exemplo 2changes são dadas pelas primeiras
	changes

		3 ALGORITHM
		
		start wit [A,A,A,A,A]
		then put but B (B,A,A,A,A)
		and (A,B,A,A,A)
		and (A,A,B,A,A....
		and so on shifting one element at a time. and also from last to begin
		
		