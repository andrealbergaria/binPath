//  // The algorithm works by first getting a base of 0000, and change one bit at a time (0001,0010,etc) compared to the base;
// Then it uess a base of 1111 and change one bit at a time (1110,1101,etc...)
// this can be used in arrays
// if you have three bytes {0,0,0} (this 0 can be anything),like {"str","str2","str3"}
// then start by {str, str ,str}
// and keep changing {str,str,str2}
// {str,str2,str} , etcetcetc
// 0 = str
 //  0 = str2
  // 0 =str3

//1=str
//1=str2
// 1=str3

// another view of it, is that 0= 0 and 1=[1,2,3] for example...in this case the 111111 cases needs to invert the zero and the set ([1,2,3]

// link with -lcrypt

/*
 * 
 * 
 * Why assigning one byte to letter doesnt works
 * 
 *  Byte1  Byte2  Byte3 Byte 4  (2^256  a lot of combinations...)
 *  256     256     256  256
 *
 * 4bits 4bits 4bits (2^4 16 possible combinations for letter) 
 * 
 * Concat binary numbers not equal to all possible combinations 
 * 
 * Also , assigining 00 | 00 | 00 |00 to 00000000,00000000,0000000,00000 doesnt work
 */
/*
                 * 
                 * 
                 * A00010000lgorithm , only works with number of bits <= 3
                 *  000
                 *  001
                 *  010
                 *  100
                 *  111
                 *  110
                 *  101
                 *  011
                 *  on this phase keep changing bits (like for example 101 or 011 until all acouunted for
                 * 
                 * 
                /*
                 * For 4 bits , needs
                 * 3,5,6,7
                 * 
                 * 
                 * For 5 bits, bits needed 
                 * 3,5,6,7,9,10,11,12,13,14,15
                 *
                 *
                 *  For 6 bits needs
                 * 3,5,6,7,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31
                 *  
                 * 
                 *  Trying to find seq of numbers not already taken
                 
                
                sequence of numbers not to be filled  a) 3,5,6,7
                12,10,9 => Numbers reverse from previous sequence a)
                
                3d = 0011
                inv(3) = 1100 = 12d
               
                 
        
                // 8 -> numero de posicoes
                // first 4 -> numero de digitos 
                // Arep(4,8) = 4^8 = 65535
                
                
                
                // Ascii vaule 'c'  => 67
                // Ascii value '0' => 48
                
              
           
                
                0101 | 0100 | 1010 | 1010 | 1011 
                 F      E      K      K     L    
                 
                 
                    x=0 , y=4, f(x) =x+4        
                    x=1, y= 5 f(x) = x+4
                    x=2 , y=6 f(x) = x+4
                    x=3 , y=7 f(x) = x+4
                    
                    what number to sum to first combination
                    
                    quero testar = 256 combinations
                    
                        1 10
                    0   1  2        1+2 = 3d  ..possible combinations = 8 = > combinations
                    
                    +3 +3 +3        3d+9       3d =    11 b
                    11 100 101
                    3  4   5    3+4+5  = 12d   12d=     1100b
                    
                    
                    
                     /* 
            *   Using 4 bits per letter
            * 
            *   A A 
            *   A B ++
            *   A C ++
                A = 0000 0d    
                B = 0001 1d
                C = 0010 2d
                
                D = 0011 3d
                E = 0100 4d
                F = 0101 5d
                
                G = 0110 6d
                H = 0111 7d
                I = 1000 8d
                
                J = 1001 9d
                K = 1010 10d
                L = 1011 11d
                
                M = 1100 12
                N = 1101 13
                O = 1110 14
                
                P = 1111 15
                 4 ^ 4 = 256
                    possible combinations 256
                    
                    00 | 00 | 10 | 10  = 10d 
                    
                    {
                        01 00 = 4d
                        00 10 = 2d
                    }
                    
                    00 | 00 | 11 | 00 = 12d
                    1100 = 12d
                  
                    
                    00 | 00 | 00 | 01 = 1d
                    00 | 00 | 00 | 10 = 2d
                    00 | 00 | 00 | 11 = 3d
                    00 | 00 | 01 | 00 = 4d
                              
                               A = 0000 0d    
                               
                 000 0d
                 001 1d
                 010 2d
                 100 4d
                 
                 101 5d
                 110 6d
                 111 7d
                               
                               
                    Quero evitar usar os numeros duma vez (maiores numeros represenetam os anteriores)
                    
                1000  (8,0 ) (1comb)
                
    dont use {   1001 (8,1)  (0comb) 9d // preciso de arrnjar numeros que conteham 9 
                1010  (8,2)  (0comb) faltam 9,10,11,12,13,14,15
                1011  (8,3)  (0comb)
                1100  (8,4)  (0bom)
                
             .... }  
                
            10000  (16,0)
    dont use { 10001  (16,1)
                            falta 17,18,19,20,21,22,23,24,25
            .....}
               
               9+10+11 = 30d 01 11 10 = {16,12,2}
               12+13+14 = 39d 10 01 11 =   {32,4,3}
               15+16+17 = 48d 11 00 00 = {16,32}
            
            10 10 10 b = 42d
            // Todas as possiveis combinações com 9
            
                                
            01 01 01, {16,4,1} 16+4+1 = 21d
            10 10 10, {32,8,2} 32+8+2 = 42d
            11 11 11, {48,12,3} 48+12+3 = 63d
            
            tenho {1,2,3,4,8,12,16,32,48} (diviseis por 2?)
            tentando {3,6,9,12,15,18,21,27,30,33,36,39,42,45,48}
                             2^4 2^2
           01 01 01  {16,4,1} 16,4,1
                             3^4 3^2 3^0
                             27, 9, 1
           3*2
           3*3
           
                                5   = 5 
                                5*2 = 10 
                                5*3 = 15
            
            
            
            
       1 -> numero   (01)       01 00 00 00 (first pos) 64d
                   2 -> numero   (10)       00 10 00 00 (2nd position) 32d
                   2 -> numero   (10)       00 00 10 00 (3rd position)  8d
                   1 -> numero   (01)       00 00 00 01 (4th position)  1d
                   
                   {1,2,1,2}
                   
                   1 -> numero   (01)       01 00 00 00  (first pos) 64d
                   2 -> numero   (10)       00 10 00 00  (2 pos ) 16d
                   1 -> numero   (01)       00 00 01 00  (3pos) 4d
                   2 -> numero   (10)       00 00 00 10 (4 pos ) 2d
                   
                   {1,2,2,3}
                   
                   1 -> numero (01)  01 00 00 00 64d
                   2 -> numero (10)  00 10 00 00 32d
                   2 -> numero (10)  00 00 10 00 8d
                   3 -> numero (11)  00 00 00 11 3d
                   
                   
                   
                   
                   
                   
                   
                    12 13 14 15 15+14+13+12 = 54 
                   
                        f(G) = {0,1,10,11}
                    100  101 110 111 2^3 = 2*2*2 = 8 comb
                    
                     G= 4 , g=5, g=6, G=6
                    quero converter letra em bits
                    
                    
                    
                G G   8*8 = 64 combinations
                
                f(letter) = 
                
                 Get all combinations
                 
                 1111 1111  => 2 ^ 8  => 256 numbers 256 combinations
                 
                 0000 0000 => 1 combination
                 0000 0001 => 2 combination 
                 
                  P     P           
                 1110 1111 => PP 1 combination 
                  O     P
                 1101 0001   PB   1 combination 
                  N     B 
                  
                  
            convertByteToAscii(v1,0xf0);
             convertByteToAscii(v1,0x0f);
                    v1++;
                    

        
                digits = 15
                pos = 2
                 
                 
                Ar(15,2) =  15 ^ 2 = 225
                2^8 = 256
                
                       

        

            
            
            
