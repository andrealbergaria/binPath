
#include <stdio.h>


//  // The algorithm works by first getting a base of 0000, and change one bit at a time (0001,0010,etc) compared to the base;
// Then it uess a base of 1111 and change one bit at a time (1110,1101,etc...)
// this can be used in arrays
// if you have three bytes {0,0,0} (this 0 can be anything),like {"str","str2","str3"}
// then start by {str, str ,str}
// and keep changing {str,str,str2}
// {str,str2,str} , etcetcetc 
// 0 = str
 //  0 = str2
  // 0 =str3
   
//1=str
//1=str2
// 1=str3

// another view of it, is that 0= 0 and 1=[1,2,3] for example...in this case the 111111 cases needs to invert the zero and the set ([1,2,3]



                
                  
2bits)                  // use xhg (asm) to a=b b=a
                 //aa
                   ab (XOR)
                   ba (REVERSE)
                   bb (XOR)
                   
                           10 00 10 (rev(b)) (34d)
                   
                  
                //how can one invert a set?
                 
                 
                 
                
                
                
                 //7 solution
                 // each bit indicates if the character is present on the number
                 // so for instance (abc = 111
                 //a=1
                 //b=1
                 //c=1
                 // for b=0 , 101
                 
                 // solution ( i think already tried)
                 // for each bit , there is a change in the set. position or substituing
                 
                    
                   // solution Assign a=01 b=10 e c=11  each variable is equal to the before plus 1 
                      
                        acc    011111 1 
                        cac    110111 2
                        cca    111101 3
                        
                        bcc     101111 4
                        cbc     110111 5
                        ccb     111110 6
                        
                        cbb     111010 7
                        bcb     101110 8
                        bbc     101011 9
                        
                        abb     011010 10
                        bab     100110 11
                        bba     101001 12
                        
                        baa     100101 13
                        aba     011001 14
                        aab     010110 15
                        
                        caa     110101 16
                        aca     011101 17
                        aac     010111 18
                        
 
                 
          
                // inversions
                inverseOf(a) = b (b=a also works)  add value 1 to a , or substact value 1 to b
                inverseOf(c) = z (z=c works)
                
                
                One
                o = 11 = c;
                Zero
                z =0 
                
                z = 0
                a = z + 1 = 01;
                b = z + 2 = 10  (b= a+1) 
                c = z + 3 = 11  (c= b+1)
                o = c = z+c = 11
                
                c=o ???? its why were using only 2 binary digits, for a total of 4 elements, so o can't appear
                
                inverse
                z = 1
                a = 10
                b = 01
                c = z
                o = 00 = c = z
               
                [a,b,c]
                
        // In the case , a,b,c use the truth table
                a=z+1 ==> 01
                b=a+1 ==> 10
                c=b+1 ==> 11
                d=c+1 ==> 100
               
                
        // how do you invert the elements of a set
                            
                        
                        10 01 01 
                        11 01 01 
                        //one bit to change the abb (either shift, or add, or subtract, or rotate)
                        
                            
                            
                  a)    xor A 10 01 01      (baa)  => 1+4+32 = 37
                          B 11 01 01      (caa) => 1+4+16+32 = 55
                          ---------
                            01 00 00          +16 (01 00 00) (left shift de quantos ? 4bits , A << 4 or B << 4)
                                                                   
                        in this case, in a , the addition must be performed , because that would evenrtually be a negative number
                            
                 b)    xor 11 01 01           (caa) 1+4+16+32 = 55
                         10 01  01          (baa) 1+4+32 = 37
                         01 00  00   // +16 
                                    //xor use to subtract

                                    
                                    
                        37+55 = 92
                        complement(37) = 10 01 01 (37
                                         01 10 10 (28)
                                         ---------
                                    +    11 01 01 => 1+4+16+32 (53)
                        55-37 = 18 
                        37-55 = 10 01 01 - 
                                    
                        in this case, in a ,a subtraction must be performed , because that would evenrtually be a negative number
                                    
                                    
                                    can a xor, give a negative value=?
                                    
                                    
                    xor can be used to add and subtract
                                    
                        to add, A xor B, to subtract B xor A
                        
                        
                        
                        
                        
                        
                    xor bba = 10 10 01
                        bbc  = 10 10 11
                        -----------------
                        
                        000010 // +2  (flip de quantos ? 000000 >> 6
                        
                        10 10 10 bbb
                        10 10 11 bbc
                        
                        000001 +1 (xor)
                        
                                  (bbb)
                        10 10 01 (bba)
                        
                        00 00 10 +2 (xor)
                        
                       // several adds, will result in the binary number
                        
                       /*  11 11 11 ccc  
                         11 11 10 ccb
                         --------
                         00 00 01 (zza) +1
                         
                         11 11 11 ccc
                         11 11 01 cca
                         --------
                        00 00 10 +2 (zzb)
                        
                        11 11 11 ccc
                        11 11 11 ccc
                        --------
                        00 00 00  +(zzz) +0
                        */
                        
                         11 11 11 ccc  
                         11 11 10 ccb
                         --------
                         00 00 01 (zza) +1
                         
                        
                        
                        10 10 10 bbb
                        10 10 11 bbc
                        --------
                        00 00 01 (zza) +1
                        
                        
                        a->b  +3 (aaa,aab) last pos
                        c->a +2 (ccc,cca) last pos
                        c->z +1 (ccc,ccz) last pos
                        
                        xor must be equal to +1 (1st round)
                        
                      a  00 00 
                      b  00 01  a^b = 00 00 xor 00 01 = 0001 = b^a
                        
                      ab=ba
                      
                     
                      
                                    
                     a 00 00 
                     b 00 01 add a+1 (ab=ba)
                     -------
                           1
                           
                    
                    2nd round    +2
                     
                     a  00 00
                     c  00 10  add a+2  a^c = 0010 = c^a
                     
                      
                   3rd round
                    
                    b 00 01
                    c 00 10   add a+3   b^c = 0011 = c^b
                    
                //its all equal from on now
             
             
             from the above, 
             z=00
             a=01
             b=10
             c=11
             
             // to get the bytes from the variables, for instance to make a= ? to use 2 bytes, 
             a) 2bytes-> 1 byte (shift left 2 bits)
             
             
             3bytes-> a) 2bytes -> 1byte
             
             3) bytes shift left 2 bits + shift left 2 bits (4 bits)
             
             
             // todos os shifts bits qualquer que sejam o numero de bytes, vao originar os elementos (a,b,c)
             
             // para numBytes = 3 , shift left 4 bits
             // para numBytes = 4 , shift left 6 bits
             
             For (number = 00 00 01 => z b then shift 4 bits turns on, bz optimization!!!)
             
             
             // for zeros (z) use the shift 2 bits
             // for xhanging positions of varaibles rather than zeros, one uses the xgh operator (like in asm)
                
                // the objective it sum the last statement with +1
             
             
                // the changing in the third position is number+1
                
                
                01 00 00 => +1   => 01 00 01
                a  z   z            a  z  a
                
                00 00 10 => +1 => 00 00 11
                z  z  b           z  z  c 
                
                01 01 00 => +1 => 01 01 01
                a  a  z             a   a  a
                
                11 11 00 => +1 =>  11 11 01
                c  c  z             c c a           
                
                
             
               01 01 00 => +1 => 01 01 01
               a  a  z           a  a  a
               
               
               
               10 00 00 => -1 => acc
                b  z  z 
               01 00 00 => -1 => zcc
                a  z   z
                
                String t2 = "not calculated, assumed"
                
                
                
                -1,-2,-3,4 = change in the third position
                -5,-6,-7,-8 = change in the third position
                -9,-10,-11-12 = change in the third position
                -13,-14,-15,-16 = change in the third position
                -8,-9 = bbz -> bac = 
                -12,-13 = baz -> bzc = 
                -16,-17 = bzz -> acc
                -20,-21 = acz -> zbz = 
                
                
     here)           so from baz to bzc , there are 8 positions
                string t = counting from the original
                    baz +1 t = baa
                    baa +2 t = bab
                    bac +3 t = bbb
                    baz +4 t = bbz
                    baz +5 t = bba
                    bar +6 t = bbb
                    bar +7 t = bbc
                    bar +8 t = bcz
                    
                    so from acz to zbz = -20,-21
                    acz +1 t = aca
                    acz +2 t = acb
                    acz +3 t = acc
                    acz +4 t = bzz 
                    acz +5 t = bza
                    acz +6 t = bzb
                    acz +7 t = bzc
                    acz+8 t =  baz
                    acz+9 t =  baa
                    acz+10 t = bab
                    acz+11 t = bac (t2)
                    acz+12 t = bbz
                    acz+13 t = bba
                    acz+14 t = bbb (t2)
                    acz+15 t = bbc (t2)
                    acz+16 t = bcz
                    acz+17 t = bca
                    acz+18 t = bcb
                    acz+19 t = bcc (t2)
                    acz+20 t  =czz                  
               11 00 00 (czz) => -1 => bcc
                                 -2 => bcb
                                 -3 => bca
                                 -4 => bcz
                                 -5 => bbc (subtracts 2pos from previous and adds z to c from -1)
                                 -6 => bbb
                                 -7 => bba
                                 -8 >= bbz
                                 -9 => bac (subtracts 2nd pos and adds z to c)
                                 -10=> bab
                                 -11 => baa
                                 
                                 -12 => baz
                                 -13 => bzc (adds 8 positions , check here)
                                 
                                 -14 => bzb
                                 -15 => bza (t2)
                                 -16 => bzz (t2)
                                 -17 => acc 
                                 -18 => acb (t2)
                                 -19 => aca (t2)
                                 
                                 -20 => acz (t2)
                                 
                                    adds(last, and makes a carry from c-> b,
                                        z -1  = 
                                        ab
                                    )
                                 -21 => abc 
                                 
                                 20 em binario =  = 010100
                                 21 em binario = 010101
                                 11 00 00
                                 
                                 
                                 -22 => caz
                                 
                                 
                                 // base 00 00 01
                                 +1 => 00 00 10 (zzb)
                                 +2 => 00 00 11 (zzc)
                                 +3 => 00 01 00 (zaz)
                                 +4 => 00 01 01 (zaa)
                                 -1 => 00 00 00 (zzz)
                                 -2 => ???
                
                                // base 11 01 00
                                    +1 =>  caa
                                    +2 =>  cab
                                    +3 =>  cac
                                    +4 =>  cbz
                                    -1 =>  czc
                                    -2 =>  czb
                                    -3 =>  cza
                                    -4 =>  czz
                
                z = 0
                a = z + 1 = 01;
                b = z + 2 = 10 and b= a+1 
                c = z + 3 = 11 and c= b+1
                o = c = 1
                
                //b z (shift left 4 bits)
                
                
                
               xhg(a,b) = ba
               
               
               
                [z,a,b,c] 4*4*4 = 64
                
                 {[1,2,3] = perumtations with repetations= 27
                
                
                    xor = equivalent to adding +2 to a number
                            
                        (baa == caa) // change in one pos (not from base)
                        (aba == abb)
                        (aab == bab)
                       
                        bab = aba (inverse) = bba (shift) = baa (shift) = caa (shift) = acc(inverse) = aca (shift)
                        = cac (reverse) = cab (shift) = aab (shfit) = acb (shift) = ccb (shift) = cca(shift)
                        = bca(shift) = bcc(shift)
                        
                      
                        
                        
                                
                                shift (da base bbb)  shift  shift
                    1)    (abb ==     bab         == bba == 
                        
                                shift (da base aaa)
                   2)     (baa == aba == aab)
                        
                                shift (da base ccc)
                   3)     (acc = cac == cca )
                        
                                shift(base aaa)
                   4)     caa = aca = aac 
                        
                        
                                shift(base bbb)
                   5)   cbb => bcb => bbc
                        
                                shift(base ccc)
                   6)     bcc => cbc => ccb
                        
                        
                        using two bases, we can invert the result(for example  reverte the results in 1) to 2)"
                        
                    
                    // base(aaa)
              2)    baa 
                    aba
                    aab
                    
                    abb // inverse a 2 , base bbb
                    bab  
                    bba
                    
                    
                    // base (ccc)
              3)    acc
                    cac
                    cca
                    
                    // nao precisa de base (inverse of 3) base aaa
                    caa
                    aca
                    aac
                    
                    
                    //base ccc
                4)  bcc
                    cbc
                    ccb
                    
                    cbb // base bbb inverse of 4)
                    bcb
                    bbc

  

            
    
    

use 1 bit b, shift it 3 times, like abb , bab,bba
                                    invert
                                    baa,aba,aab
                                    
use 1 bit b, shift it 3 times , cbb,bcb,bbc
                                invert
                                bcc,cbc,ccb

use 1 bit b, shift it 3 times , acc,cac,cca
                                caa,aca,aac
                                

                 for 0='b' and 1='a' ==> 3 ops
                 for 0='b' and 1='c' ==> 3 pos
                 
                 for 0='c' and 1='a' ==> 3 pos 
                 for 0='c' and 1='b' ==> 3 pos 
                     
                 
                for (iterator = 1 ; iterator < 2; iterator++ ) {
                       zero[iterator-1] = 0;
                       zero[iterator] = 
                 
                 }
                 

                 
                 /* para cada shift right [01,10,11]
                  *                         a  b  c
                                          [00,01,10]
                                            z a b
                                          [00,00,01]
                                            z z a
                                          [00,00,00]
                                            z  z z
                para cada shift left [01,10,11]
                                       a  b c
                                     [10,11,00]
                                      b  c z
                                     [11,00,00]
                                     c z z
                                     [00,00,00
                                    z z z
                {[1,2,3] = perumtations with repetations= 27
               
               [1,2,3] is used (pos(0) = 1  , pos(1)= 2 , pos(2) = 3 (because on each position , one increments the before)
                                    
                 
                  assign 00000000 = [1,2,3]
                  assign 00000001 = {1,2,3]  (var=1 1 change to set)
                  assign 00000010 = {1,2,3]  (var=2 (correspond to 2 changes to set)
                  assign 00000100 = [1,2,3] (var=3 (correspond to 3 changes in set)
                  total permutations = 2+4+8+16+32+64+128+256 = 509 
                  
                  
                  
                  if it was binary code, then we would make a shift, in thise case we change pos
                      
                1)    100
                2)    010
                3)    001 pos(0) =pos(1),pos(2)=pos(1)  (2shifts, 0 -> 1 , 1->2, um shift uma posicao++)
                      
                     
                      3bits=8 orders
                      
                      e se eu fizer o shift, com posicao fixa no bit anterior
                      
                      01 01   ( ==> correspond to 100 , on the last seq (1)) 
                      01 10   ( ==! correspond to 010 , on the last seq(2) shift efectuado (01 01
                      10 10                                                                  01 10                                                                      
                      10 01   ( ==> correspond to 001, om the last seq(3) , shift efectuado (10 01
                                                                                            10 (01)
                                                                                                            
                    
                    num da posicao = numero binario (nao resulta)
                      000 = position(0)
                      001 = position(1)
                      010 = position(2)
                      100 = position(4)
                      
                      
                      
                     // equal one bit digit to a position, and other digit to a position  (1=1 0=2)
                     // 1=01 0=10
                     // so the bit 1 is equal to 1 position
                     // so the bit 0 is equal to 2 position
                     
                    so if the elements are two, then we case use the algorithm
                    
                    if the elements are three?
                        if the elements are three
                        => 000 (3bits) , 1st bit = 0 ... 2nd bit = 0 ...3rd bit = 0
                                                   1               1            1
                                        
                                        1st bit 
                                        1
                                        0
                                        
                                        if elements are 2 (like [a,b]), then 1st bit must be multiplied by 2
                                        1st bit must be 2nd bit uses 1st bit,
                                        
                                        2nd bit is 1bit , 1 bit
                                        
                                        0 0 A = (2nd bit = xor first bit ^ 0) 
                                        0 1 B = (2nd bit = xor first bit ^ 1 )
                                        1 0 C = (2nd bit = xor first bit ^ 1)
                                        1 1 D=  (2nd bit = xor first bit ^0 )
                                        
                                        B=C, A=D
                                        
                                        3 bits
                                        

                    bit 0 = pos(1)
                    bit 1 = pos(2)
                    bit 2 = pos(3)
                    
                    
                    
                    
                        
                    100 (1,2,2) 
                    010 (2,1,2)
                    001 (2,2,1)
                    
                    // bit 1 = 2, bit 0=1
                    100 (2,1,1)
                    010 (1,2,1)
                    001 (1,1,2)
                      
                   [2,3,4] 
                   1000  (1pos,2pos,2pos)
                   0100  (2pos,1pos,2pos)
                   0010  (2pos,2pos,1pos)
                    
                   
                   1000 (1000,0010,0010)
                   0100 (0010,1000,0010)
                   
                   
                   
                   so if i follow the algorithm (0000 00001 0010 0100 1000, 1111 1110 1101 1011,0111)
                   it woudl work
                   
                 
                 8 shifts, 8 positions, 
                 8 shifts , 8 positions (comecando no 11111111)
                 1 shifts = troca o ordem (posicaoo) entre 000000001 = 1  
                                                           000000010 = 2

                2nd shift = 00000010    =2 
                            00000100    =4
                            
                            // um shift aumenta a posicao por 1
                            shift = posicao+1;
                // trying three bytes
                [1,1,1]  
                // What changes in between [], is the position
                [3,1,1] -> 00000001 , pos(0),pos(1),pos(2)
                [1,3,1] -> 00000010
                [1,1,3] -> 00000100
                
                [2,1,1] -> 00001000 , pos(0),pos(1),pos(2)
                [1,2,1] -> 00010000
                [1,1,2] -> 00100000
                
                [2,2,2] -> 01000000
              
                [1,2,2] -> pos(0),pos(1),pos(2)
                [2,1,2]
                [2,2,1]
                
                [3,3,3]
                
                [1,3,3]
                [3,1,3]
                [3,3,1]
                
                [2,3,3]
                [3,2,3] -> pos(0),pos(1),pos(2)
                [3,3,2]
                
                
                
                
                
                // 2nd byte
                [1,1]
                [1,2]
                [1,3]
                [2,1]
                [3,1]
                [2,2]
                [2,1]
                [3,1]
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 
                 [1,1,1]        00000000 
                 [3,1,1]        00000001 pos(0)
                 [1,3,1]        00000010 pos(1)
                 [1,1,3]        00000100 pos(2);
                 
                 [2,1,1]        00001000 pos(3);
                 [1,2,1]        00010000 pos(4);
                 [1,1,2]        00100000 pos(5);
                                01000000 pos(6);
                                10000000 pos(7)
                                         
                                         
                                         
                                         
                                         cada bit shift , transforma 
                                        (00000000 -> 00000001) pos_do_bit1(0)
                                           0     -> 1
                                          00000000 -> 00000010 pos_do_bit1(1)
                                            0     -> 2
                                            
                                            1 2 4 8
                 [1,2,2]
                 [1,2,3]
                 [1,3,3]
                 
                 [1,3,2]
             
                  
                 
                 // 3rd bytes
                 
                 
                 // 3rd bytes
                 char threeBytes_firstHalf[4];
                 char threeBytes_secondHalf[4];
                 
                 for (iterator=0 ; iterator < 3; iterator++) {
                     threeBytes_firstHalf[iterator] = firstHalf(iterator);
                     threeBytes_secondHalf[iterator] = secondHalf(iterator);
                 }
                 
                 
                
               // thing is, use the algorithm on a binary string like 0b1010101111100 (always bit shift 1)
                
}



// test 
/sera que é shift duas ou mais vezes (mais zeros?, por exmepl 11100 , 11000)
5 bits

00001    1    
00010   2
00100   4   
01000   8
10000   16

preciso de 
3,5,6,7,9,10,11,12,13,14,15

00011 3   (flip the bit , ignore zeros suffix)

add 0

000   0
001   1    
010   2
100 = 4

111   7  rev 0
101 = 5 rev 2
011 = 3 rev 1
110 = 6



    
    
4 bits)
---vao ser invertidos (de 0000,0001,0010,00 para 0111,0110, e parra 111,1110..)
1) 0000   0 
 0001   1 
 0010   2 
 0100   4 

2)  0 111  7 
    0 110  6 (changed one bit related to 111)
    0 101  5 (changed one bit related to 111)
    0 011  3
 
 -----------------
 para isto
 
3) inverteu 1) para 3)
 1111   15  (inverteu 1) para 3)
 1110   14  (changed on bit related to 1111) 
 1101   13  (changed on bit related to 1111) 
 1011   11  
 
 --------------

4) (inverteu 2) para 4) 
 
 1000 8 inv 7
 1001 9 inv 6
 1010 10 inv 5
 1100 12 inv 3
 
------------------------

para 4 bits, tem-se o 1 e 2 , e inverte-se par 3 e 4, usando o algoritimo...
 
 
 
 
 ignore 5 first bits, if they equal 0
 8bits)
 1)
    00000000   (base 00000000)
    00000001    1 
    00000010    2 
    00000100    4 
    00001000    8 
 

 faltam 9,10,11,12,13,14,15,17 
    
 
 2) 00010000 (base 00000000 1) ,relation to 1) continues in 2)
    00100000 32 
    01000000 64 
    10000000 128

 6)  inverted 1)
    ----------
    11111111 (base 11111111,inverse of 1) 255
    11111110  254
    11111101 253
    11111011 251
    11110111 247
    
7)   inverted 2)  (base 11111111)
    11101111 239  6) continues in 7)
    11011111 223
    10111111 191
    01111111 127

    
8)    
      00000011 3d (base 00000011)
      
      
      
9)  111111110 (revert base 00000011)  ===>  equal to 6)
    111111101
    
    
10) 00000101 5d (base 00000101)
    00000111 7d
    00000100 4d
    00000001 1d 
    
    
11) reverse 10) (base 11111010)
    11111110
      
      
      
 10)   inverse of 8) base(11111000), so i inverse the base (00000111) and go from there
    11111000
    11111001
    11111010
    11111100
    
    
      
11) inverse of 9
    01111000 , base (11111000) same of b) , 11) succeeds   to 10)
    10111000
    11011000
    11101000
    11110000
    

12) base = 11000111
   11100111
   11010111
   11001111
   11000011
   
13)   
   10000111
   01000111
   11000110
   11000101
   
   
   divide 8 bytes in two groups... The two groups of bytes, have all the bits equal to the base except one bit. The inverted groups from the originals , have a inverted base, and all bits are equal except one bit to the inverted base;
    
    
    inverting one group of bytes,(4 bytes) , inverts all the bits from those bytes (for example, 1100 to 0011, and inverts the base;
    
6)    
    (base 11111000)
    ------------
    11111001   249 rev 6
    11111010   250 rev 5
    11111100   252 rev 3
    
    
    
    
    ---------
    
   1) equals to another bytes, even if ones goes right or left)
                                                
    
 

    
 add 8d (the first bit), to the three bits (like for instance 000 => 1000, and 001 => 1001) to get the numbers
 or
 add 16 to the (binary numbers that have three bits, getting 5 bits).
 
 set the first bit to 0,1,10,11,100
 
  0 => 3 bits  (add 0)
  1 => 4 bits (add 8)
  10 => 5 bits (add 16)
  11 => 5 bits (add 24)  
  
  
  100 => 6 bits (add 32)
  101 => 6 bits (40)  
  110 => 6 bits (48) 
  111 => 6 bits (56) 
                    
  4 bits .... have(1 bit  | 3 bits) add bit
  5 bits .... have(2 bits | 3 bits) add bit
  6 bits ,,, have (3 bits | 3 bits) add bit
  7 bits ... have (4 bits | 3 bits) add bit
  8 bits ... have (4 bits | 4 bits) 
  
  7 bits ... have (1 bit | 3 bits | 3bits)
  8 bits ... have (1 bit | 3 bits | 1 bit | 3 bits)
                0 or 1   | base bits  | 0 or 1 | base bits
  
 0000
 0001
 0010  4 bits -> 2^4 -> 16
 0100
 0011
 0101 
 0110
 0111
 
 
    5 bits -> 2^5 bits
    
    
    3bits left  3 bits right =0
    3bits right 3 bits left = 0
    
    
    111 000
    000 111 
    
    111 111
    000 000
    

 
1 000 1 000
1 001 1 000
1 001 1 001
1 001 1 010 
 
shift left 4

1 010 0 000

try to ignore leading digit, so to become 3 bits and then use the algorithm
9,10

(it works with base 111 (inverting, ingoring leading zeros (until it reaches the bits which are assured);




 //  char *tempVar = (char *) malloc(500);
  //  tempVar = base;
    
    
    
    
   /* v[0][0] = base[0]; // 0
    v[0][1] = base[1]; // 2    
    v[0][2] = base[2]; // 4
    v[0][3] = base[3]  // 8
    
 
    var = [elems] | base[]
    
    var = ELeems | 000
    var = ELeems | 001
    var = ELeems | 002
    var = ELeems | 003
    
    var = 0 | 000 
    var = 0  | 001 
    var = 0 | 010
       v[it] = 0,1
    var = 1 | 00  // so precisa mudar 1 elemento da array
    */
    
    
     // 256 bits , em bytes são 32
	   // 32 bytes / 4 bytes (size of int) = 8
	    //64 bits * 4  = 256 ..
	    // Function for getting chars
	    // f(pos) = 8k+pos


	      //32 bytes need need 8 ints
	    // 8*32 = 256  (one byte, combinations)
	   // 8* 8192  = 65536 (two bytes,combinations)
	   // 8* 536870912  = 4294967296 (4bytes , combs)


	          // FROM https://stackoverflow.com/questions/34357968/how-to-set-first-three-bytes-of-integer-in-c
	          /*int a = 4294967233;
	                char* p=&a;

	                p[0] = whatever you wanted there
	                p[1] = whatever you wanted there




	      double res;  %f
	        int *currentByte = &res;
	


	            unsigned int array_base[8] = {0x00010203,0x04050607,0x08090A0B,0xC0D0E0F};
	            unsigned int mask_add_8 =    0x08080808;
	            printf("\n");
	            char *ptr = (char *) &array_base[0];


	            
	             Number of combinations


	            unsigned long // 8 bytes  +  18,446,744,073,709,551,615]


	            printf("\nNumber of combinations : %i\n", numberOfCombinations );
	            array_base[0] += mask_add_8;
	            array_base[1] += mask_add_8;
	            numberOfCombinations+=4;

    //char positions[] = { *ptr1 , *ptr2 , Ptr3 ,*ptr4

    
     /*    // Portanto os templates sao todosd os posisveis dum numero
            //o numero pnao pode estar contido noutro sitio (indicado pleos zeros)
            
            
            
               //n -> Número de elementos do conjunto.
    //p -> Quantidade de elementos por agrupamento
    //Arranjos = pow(n,p);
  //  n=8, p=4 = 4096
            
            [ 1,1,1,1 ]
            [ 1,1,1,0 ]  || equal to below
            [ 1,1,1,0 ] 
            [ 1,1,1,0 ]
            [ 1,1,1,0 ]
            [ 1,1,1,0 ]
            [ 1,1,1,0 ]
            [ 1,1,0,0 ]
            [ 1,1,0,0 ]
            [ 1,1,0,0 ]
          
          }  
          
          //     printf("\n { '%c','%c','%c' , '%c', '%c' ,'%c' , '%c','%c' }    it (%i)", \
                                    		pos1_ptr[i1],pos2_ptr[i2],pos3_ptr[i3],pos4_ptr[i4], \
                                    		pos5_ptr[i5],pos6_ptr[i6],pos7_ptr[i7],pos8_ptr[i8],\
                                    		total_iterations);
                                 
                               		
   							Pos 1			Pos2=pos1  		Pos3=pos1 Pos3=pos1
   Initial		x	1 2 3 4 5 6 7 8   1 2 3 4 5 6 7 8
   
   Permute		y	2 1 3 4 5 6 7 8   1 2 3 4 5 6 7 8
   
   				z	2 1 4 3 5 6 7 8  1 2 3 4 5 6 7 8
   
   
   					finished permutation position 2
   			a		1 2 3 4 5 6 7 8   1 2 3 4 5 6 7 8 x
   					1 2 3 4 5 6 7 8   2 1 3 4 5 6 7 8 y
   					1 2 3 4 5 6 7 8   2 1 4 3 5 6 7 8 z
   					
   					copiar permutation(x,y) -> pos2(x,y)
   					copiar pos2(x,y) -> pos3 (x,y)
   					
   					Pos1				Pos2			Pos3 , 
   					1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8   2 1 3 4 5 6 7 8 y		 	
   					1 2 3 4 5 6 7 8  1 2 3 4 5 6 7 8   2 1 4 3 5 6 7 8 z
   					
   					
   					
   					 
   						
   						Pos2 = pos1
   						permute one positions
   						xhg positions POs1=pos2, pos2=pos1
   						
   						
   						 
   						
   